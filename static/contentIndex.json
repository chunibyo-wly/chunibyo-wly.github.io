{"A-论文/3DLineDetection":{"title":"Fast 3D Line Segment Detection From Unorganized Point Cloud","links":[],"tags":["点云"],"content":"\n\n代码注释地址。\nPoint Cloud Segmentation §\n\nNormal Calculation\n\n先用 KNN 找临近点。\n然后对这些点使用 PCA。\n得到向量 n，曲率λ，点尺度s(临近点间距离)\n\n\nRegion Growing &amp;&amp; Region Merging\n\nPlane Based 3D Line Detection §\n\n3D-2D Projection\n\n把上面区域生长拿到的平面点都取出来投影到估计的平面上。\n根据第一个投影的点建立二维坐标系然后建立栅格。\n\n\n2D Line Detection\n\n上述栅格或者说二值图腐蚀膨胀。\nfindContours\n对每个 contour 进行递归的求解直线段。\n\n\n2D-3D Re-projection\n\nPost-processing §\n\nOutliers Removal\n\nremove non-structural planes: 两个最长直线段所在方向的所有直线段长度加和，判断是否大于阈值\nremove non-structural lines: 当有大量结构化特征时，可以直接保留下来，或者单条线段质量足够好\n\n\nLine Merging\n\n计算两个端点到另一条直线的垂直距离判断是否要合并。\n计算两条直线间的 gap 比例判断是否要合并。\n合并的时候需要注意代码中直线段以向量形式存储，要注意方向问题。\n\n\n"},"A-论文/4PCS":{"title":"4PCS","links":[],"tags":[],"content":"\n\n\n\n首先有一个大循环 TryOneBase，这是一个大的循环，主要用来计算两个点集间的变换。\n\n\nTryOneBase 首先会 RANSAC P点集的三个点。主要实现在 SelectQuadrilateral 中。\n按照论文中所说，4PCS 方法首先确定的是一个共面的四元组，实际情况中，完全共面的四个点可能概率极小。所以代码中实现为寻找的是未近临三元组，且距离该平面最近的点。\n\n\n与论文中不同，代码实现对 Q 点集的查询是分两次对一组点进行筛选。\n\n首先根据颜色，法向量，距离等信息记录符合条件的第一组点对。\n以同样的方式记录第二组点对。\n第一组点和第二组点的交点应该为同一组点，但是实际情况下比较困难找到这么理想情况下的点。于是使用第一组点的假想交点构建 kdtree。然后使用第二组的假想交点进行查询。将符合阈值的两组交点加入到结果中。\n\n\n"},"A-论文/A-Survey-on-Data-Compression-Techniques-for-Automotive-LiDAR-Point-Clouds":{"title":"A Survey on Data Compression Techniques for Automotive LiDAR Point Clouds","links":[],"tags":["3D","点云","压缩"],"content":"\nCoding based §\nFormat based §\n![[E-通识/点云#[LASzip](https //www.youtube.com/watch?v=A0s0fVktj6U)|点云]]\n2D based §\n\nCartesian -&gt; Spherical\nRange image (r,θ,ϕ), pixel coordinate store value r\n\n因为是线雷达所以假设旋转平面的坐标是稠密, 也就是 (θ,ϕ) 稠密\n\n\nIntra-Frame\n\nJPEG\n\nDiscrete Cosine Transform (DCT)\nDiscrete Wavelet Transform (DWT)\n\n\nPNG\n\n\nInter-Frame\n\nLog range images\nLayered range images 多张 range image 合并重整\n\n\n\n3D based §\n\nG-PCC  \n\nTensor based §"},"A-论文/A-robust-statistics-approach-for-plane-detection-in-unorganized-point-clouds":{"title":"A robust statistics approach for plane detection in unorganized point clouds","links":["BVH","Robust-Statistics","C-项目/Open3D","并查集"],"tags":["点云","平面","Open3D"],"content":"\n\nRobust plane detection §\nSplit phase §\n\n使用 BVH 树拆分点云成尽量小的 patch\n小 patch 因为噪声的存在，可能不被判定为一个平面\n回溯的时候，如果小 patch 不是平面，测试父亲 patch 是不是平面，此时噪声可能占总点云数目比例变小了，容易符合平面判定\n\nRobust planarity test 鲁棒平面测试 §\nRobust Statistics\n平面定义 (C,N)\nC: 平面上各坐标轴中点\nN: 方向向量中点\n\n1. Plane-sample distance test §\n2. Plane-sample normal deviation test §\n3. Outlier percentage test §\nGrowth phase §\n\n对 point 建立连接图\n将检测得到的小 patch 吸收周围 point 进行生长（基于 robust statistics 的区域生长）\nOpen3D#grow\n\nMerge phase §\npatches 合并\n\n三个指标判断两两 patch 是否应该合并\n并查集合并 patch\nOpen3D#merge\n\nIterative grow-merge procedure §\n如果有合并更新，就重新进行 Growth phase 和 Merge phase"},"A-论文/S4PCS":{"title":"Super Generalized 4PCS for 3D Registration","links":[],"tags":["pcs","点云"],"content":"\n\n问题：在尺度不确定的场景下，复杂度还是 o(n2)，后续算法也有这个问题。\n这篇文章核心思想是使用八叉树和球与长方体相交算法，\n解决在已知查询第二个点云 q 长度为 d 时复杂度为 o(n2) 问题。\n\n4pcs 与 s4pcs 实现了不同的 ExtractPairs，4pcs 与多尺度的 s4pcs 都是使用的 o(n2) 复杂度逐点搜索长度。\n核心算法在类 IntersectionFunctor 的 process 方法中。\n\n首先将点云按照最长边缩放到单位长度。\n然后遍历每一个点 (primitive)，将与球体相交的方块进行多次分裂\n分为提前停止分裂的和最后一次分裂两部分的 长方体 (node) 存储进结果。\n\n\nsplit 算法\n\n首先将 xyz 投影到同一维度上，用 中值 的左右两侧表示第几块\n首先按 x 分成 2 段\n然后按 y 再将 x 的2段分为 4 段\n同样 z 会得到 8 段\n\n\n"},"A-论文/Symmetry-Loss":{"title":"Symmetry Loss","links":["E-通识/微积分"],"tags":[],"content":"\n度量对称轴将多边形切割成两份后的对称损失(SIou) L，令切分成两份的多边形面积分别为 S1​ 和 S2​ ，两个面积分别对其余凸包上的点求导。\nL 对多边形上的点 x 坐标求偏导\n\nS2​=S−S1​\nL=(SS1​−S2​​)2=(S2S1​−S​)2\n∂L=2∗S2S1​−S​∗∂S2S1​−S​\n∂S2S1​−S​=∂(2SS1​​−1)=2S2∂S1​∗S−∂S∗S1​​\n∂L=4∗S3(2S1​−S)∗(∂S1​∗S−∂S∗S1​)​\n\n原版 GIoU 损失与梯度推导\nS 表示预测凸包的面积, Sgt​ 表示真值面积(不会产生梯度), I 表示交集多边形面积, U 表示并集多边形面积\n\nL=UI​−CC−U​=UI​+CU​−1\nU=S+Sgt​−I\n∂U=∂S−∂I\n∂L=U2(∂I∗U−∂U∗I)​+C2∂U∗C−∂C∗U​\n∂L=U2(∂I∗U−(∂S−∂I)∗I)​+C∂S−∂I​−C2∂C∗U​\n\n将两者合并后损失和梯度可以分别表示为\n\nL=GIoU−SIoU\n∂L=∂LGIoU​−∂LSIoU​\n\n非独立自变量梯度计算\nTransclude of 微积分#两个中间变量--一个独立变量\n设预测点 P1​ 对称点 P2​=H(P1​)\n\ndp1​dIoU​=∂p1​∂IoU​dp1​dp1​​+∂p2​∂IoU​dp1​dp2​​=∂p1​∂IoU​+∂p2​∂IoU​⋅dp1​dp2​​\ndp1​dIoU​"},"C-项目/CGAL":{"title":"CGAL","links":[],"tags":["cpp"],"content":"Chapter 2 Basic Arrangements §\n2.1 Representation of Arrangements: The Dcel §\nDCEL: doubly-connected edge list\nx-monotone: 单调曲线\nCCB: connected component of the boundary"},"C-项目/Open3D-issue":{"title":"Open3D issue","links":["BVH","C-项目/Open3D"],"tags":["点云","Open3D"],"content":"\nissue-6550 §\ndetect_planar_patches fails with perfectly flat surfaces\nDebug 过程 §\nstatic std::array&lt;Eigen::Vector3d, 6&gt; colors = {\n\t\tEigen::Vector3d(0.8500, 0.3250, 0.0980),\n\t\tEigen::Vector3d(0.9290, 0.6940, 0.1250),\n\t\tEigen::Vector3d(0.4940, 0.1840, 0.5560),\n\t\tEigen::Vector3d(0.4660, 0.6740, 0.1880),\n\t\tEigen::Vector3d(0.3010, 0.7450, 0.9330),\n\t\tEigen::Vector3d(0.6350, 0.0780, 0.1840)};\nPointCloud dummy;\nfor (size_t i = 0; i &lt; planes.size(); i++) {\n\tauto&amp; plane = planes[i];\n\tauto pcd = this-&gt;SelectByIndex(plane-&gt;indices_);\n\tpcd-&gt;PaintUniformColor(colors[i % colors.size()]);\n\tdummy += *pcd;\n}\n\n分割 BVH 后结果正确\nMerge 没有正确合并相邻的 patch，这个函数实现可能有问题 \n在这个 issue 的数据中，大量两两 patch 的法向量点积为 1，min_normal_diff_ 也为 1，合并过程中这个[[A robust statistics approach for plane detection in unorganized point clouds#Robust plane detection#2. Plane-sample normal deviation test|阈值判断条件]]就失效了\n"},"C-项目/Open3D":{"title":"Open3D","links":["A-论文/A-robust-statistics-approach-for-plane-detection-in-unorganized-point-clouds","kdtree","并查集"],"tags":["点云","Open3D"],"content":"\nPlanDetector §\n参考资料 §\n代码入口\nA robust statistics approach for plane detection in unorganized point clouds\n代码阅读 §\nPointCloud::DetectPlanarPatches §\n函数入口\n使用 kdtree 统计每个 point 相邻的 point\nRobustPlanarityTest §\n函数入口\nGrow §\n函数入口\n\n根据噪声度量 min_normal_diff_ 从小到大排序\nqueue 取出噪声最小的 patch，每个 patch 和 point 只使用一次\n判断内点\n\npatch 和 point 法向量点乘大于 min_normal_diff\n距离小于 max_point_dist_\n\n\n\nMerge §\n函数入口\n对所有 patch 建图，计算它们间的相关关系\n\n首先判断法向量点乘差异是否满足阈值\n遍历所有平面 patch -&gt; 平面包含的点的 index -&gt; 每个点的 kdtree 的邻居\n\nplane_points 从 point 到平面 patch 的索引\n找到邻居点所在平面\n如果两平面 patch 边缘上的点满足 kdtree 能互相找到，对两平面进行鲁棒共面检测\n\n\n并查集计算\n\n默认顺序建立并查集树，此时根节点没有物理意义，任意 patch 都有可能是根节点\n使用 largest_planes 记录成为了根节点的 patch 叶子节点里面包含 point 最多的 patch\n后续合并就使用 largest_planes 指向的点最多的 patch 作为初始，合并其余的 patch\n\n\n合并共面 patch 根据现有点重新计算 max_point_dist_ 和 min_normal_diff_ 的值\n\nUpdate §\n函数入口\n\n如果 num_new_points_ 占原有点一半，就认为这个 Merge 过的 patch 不稳定，需要更新\n只要有一个 patch 更新，就要重新进行 Grow、Merge 和 Update\n\nissue §\n\n[[Open3D issue#issue-6550|issue#6650]]\n"},"D-HKU/HPC-使用":{"title":"HPC","links":[],"tags":[],"content":"https://hpc.hku.hk/hpc/\n提交 ppt 经过导师审批账号。申请成功会收到账号密码，和一般 Linux 使用方法相同可以拷贝 id_rsa.pub 给 HPC.\n网页 dashboard\n通过 module 命令加载软件，其余软件用户无法 sudo 安装，需要自己编译\n#!/bin/bash\n#SBATCH --job-name=CNN           # Name of the job\n#SBATCH --output=CNN_%j.out      # Output file (%j will be replaced by job ID)\n#SBATCH --error=CNN_%j.err       # Error file (%j will be replaced by job ID)\n#SBATCH --partition=l40s\t\t# Specify the partition (e.g., gpu)\n#SBATCH --gres=gpu:1                     # Request 1 GPU\n#SBATCH --cpus-per-task=12                # Request 4 CPU cores\n#SBATCH --mem=16G                        # Request 16GB of RAM\n#SBATCH --time=7-00:00:00                  # Set a time limit (2 hours)\n#SBATCH --mail-type=ALL                  # Notify on job start, end, and failure\n#SBATCH --mail-user=wulongyong@connect.hku.hk\t# Your email for notifications\n \n# Load necessary modules (if your cluster uses modules)\nmodule load anaconda  # Load Anaconda module (adjust based on your system)\nmodule load gcc/12.3\nmodule load cuda/11.8\n# Activate the Anaconda environment\nsource activate sympoint\n \nnvidia-smi\nPYTHONPATH=/scr/u/wulongy/workspace/CADTransformer CUDA_VISIBLE_DEVICES=0 ~/.conda/envs/sympoint/bin/python -u train_cad_ddp.py --log_dir cnn\n异地组网 §\n在内地由于跳转太多，tailscale 直连办公室电脑延迟较高。发现在家可以低延迟直连 azure (学生免费2核1G)，所以可以将 azure 加入组网，通过 azure 代理 ssh 到办公室，延迟得到大幅下降。"},"E-通识/CUDA":{"title":"CUDA","links":[],"tags":["CUDA"],"content":"# CUDA编程基础 (C++ programming)\nBuilt-in variables §\nthreadIdx: thread index within Block\nblockIdx: block index within Grid\nblockDim: thread shape\nGridDim: grid shape\nglobal array id = blockIdx.x * blockDim.x + threadIdx.x\n"},"E-通识/Llama":{"title":"Llama","links":[],"tags":["llm"],"content":"可以很方便使用 Ollama 启动 Llama, 通过指定图片路径的方式可以使用 LLM-Vision 模型。\n"},"E-通识/SVG":{"title":"SVG","links":[],"tags":["前端"],"content":"SAX §\nSimple API for XML\nviewBox §\n(minX, minY, width, height) 用来决定在整个坐标系空间中用于展示的取景范围, 其余部分会被隐藏.\nwidth, height 设定将取景框缩放到 html 展示的大小, 不会影响有哪些内容不被展示.\nTag §\nclipPath §\n裁剪框，将定义的 path 以外的元素裁切掉\nPath §\n\nM = move to\nL = line to\nH = horizontal line to\nV = vertical line to\nC = curve to\nS = smooth curve to\nQ = quadratic Bézier curve\nT = smooth quadratic Bézier curve to\nA = elliptical Arc\nZ = close path\n\n大写：绝对路径\n小写：相对路径\n实用工具：svgpatheditor"},"E-通识/wsl":{"title":"wsl","links":["tmux"],"tags":[],"content":"Daemon §\nLet wsl start without user login.\nUse tmux to create a fake window and keep writing Logs.\n&amp; &#039;C:\\Program Files\\WSL\\wsl.exe&#039; -e /home/chunibyo/.tmux_startup.sh\n#!/bin/bash\n \nFLAG_FILE=&quot;/tmp/startup_script_executed&quot;\n \nif [ ! -f &quot;$FLAG_FILE&quot; ]; then\n    # Your commands here\n    echo &quot;Running startup commands...&quot;\n \n    # Example: Start a new tmux session with specific windows\n    tmux new-session -d -s my_session\n    tmux new-window -t my_session:1 -n &quot;tmux-startup-window&quot; &quot;while true; do echo 1 &gt; /tmp/tmux_output.txt; sleep 1; done&quot;\n \n    # Create the flag file\n    touch &quot;$FLAG_FILE&quot;\nfi"},"E-通识/微积分":{"title":"微积分","links":[],"tags":[],"content":"链式法则 (Multi-variable Chain Rule) §\n普通的链式法则 §\ndtdw​=dxdw​dtdx​\n多元函数链式法则 §\n两个中间变量 + 一个独立变量 §\n\ndtdw​=∂x∂w​dtdx​+∂y∂w​dtdy​\n两个中间变量 + 两个独立变量 §\n\ndrdw​=∂x∂w​∂r∂x​+∂y∂w​∂r∂y​\n"},"E-通识/点云":{"title":"点云","links":[],"tags":["3D","点云"],"content":"Chamfer Distance §\nd(A,B)=A∑​Bmin​∣∣a−b∣∣2+B∑​Amin​∣∣a−b∣∣2\nA 点集每个点找 B点集内最近点的距离求和 + …\nHausdorff distance §\n\nDirected Non-Symmetric\n\nh(A,B)=Amax​(Bmin​(∣∣a−b∣∣))\n\nSymmetry\n\nH(A,B)=max(h(A,B),h(B,A))\n找到 B 点集每一个到 A 点集最近的点对, 然后取出这些点对的最大距离\nLASzip §\n\nwrite header (uncompressed)\n*write points in “chunks” of 50,000\n\nstore first point raw (uncompressed)\ncompress next point\n\npredict attributes that have changed\n\nreturn number, intensity, scan angle, …\n\n\npredict coordinates using Δx, Δy, z\ntreat GPS time as integer, predict steps\n\n\n\n\n"},"Y-存档/A-工程项目/CodeWars/codewars-URLshortener":{"title":"codewars URLshortener","links":[],"tags":[],"content":"\n\nURL shortener\n题目要求：\n\n475,000个测试用例\n只能使用 26 个小写字母\n短链长度为 4\n\n有两种思路：\n1. index转26进制 §\n令a=0, 此时除0的情况外, a不能出现在首位, 长度为4的26进制的情况数有\n25∗263+25∗262+25∗261+26=456976&lt;475000\n2. index与可重复全排列双射 §\n此时a没有数学意义，可以出现在首位，所以情况数为\n264+263+262+26=475254&gt;475000\n这里在参考康托展开和逆康托展开就可以得到index和short url之间的转化关系\nbase = 26\nBASE = [0]\nindex = 0\ntable = [&quot;&quot;]\nhash_table = {}\n \n \ndef init():\n    for i in range(6):\n        BASE.append(BASE[len(BASE)-1]+base**i)\n \n \ndef get_N(x):\n    for i in range(len(BASE)):\n        if BASE[i] &lt;= x and BASE[i+1] &gt; x:\n            return i\n \n \ndef cantor(x):\n    # short to index\n    result = 0\n    for i in range(len(x)):\n        result += (ord(x[i])-ord(&#039;a&#039;)) * base**(len(x) - i - 1)\n    return result + BASE[len(x)]\n \n \ndef re_cantor(x):\n    # index to short\n    n = get_N(x)\n    x -= BASE[n]\n    result = &quot;&quot;\n    for i in range(n):\n        tmp = x // (base ** (n-i-1))\n        result = result + chr(ord(&#039;a&#039;) + tmp)\n        x -= tmp * (base ** (n-i-1))\n    return result\n \n \ninit()\n \n \ndef url_shortener(long_url):\n    global index\n    if long_url not in hash_table:\n        index = index + 1\n        table.append(long_url)\n        short_url = re_cantor(index)\n        hash_table[long_url] = short_url\n    else:\n        print(long_url)\n        short_url = hash_table[long_url]\n    return &#039;short.ly/&#039;+short_url\n \ndef url_redirector(short_url):\n    long_url = table[cantor(short_url[9:])]\n    return long_url"},"Y-存档/A-工程项目/Linux/Linux":{"title":"Linux","links":[],"tags":["linux"],"content":"\n\n文件 §\nsed §\n\n\n\ns命令\nsed &#039;s/book/books/&#039; log.txt\n\n\n\ns命令, 只打印替换过的行\n\n/p打印处理过的行\n-n仅显示处理过后的结果\n\nsed -n &#039;s/book/books/p&#039; log.txt\n\n\n\n/d命令\nsed &#039;/book/d&#039; log.txt\n\n\n\n&amp;指代已匹配的字符\nsed &#039;s/book/&amp;s/&#039; log.txt\n\n\n\n-e多次执行\n\n\na\\在匹配到的下一行追加\n\n\ni\\在匹配到的下一行追加\n\n\n;\n\n\n\n查看空格, tab\nsed -n l log.txt\n \nthis is tab\\tfinish.$\nthis is several space      finish.$\n\n\nwc §\n\n行数, 单词数, 字节数, 文件名\n\nl行数\nw单词数\nc字符数\n\ncut §\n\n\n\n按字节-b, 按字符-c\n\n\n\n-f\ncat /etc/passwd | tail -n 5 | cut -d : -f 1,3\n\n\n\nsort §\n\n-o指定文件名保存\n-f忽略大小写\n-u删除重复行\n-r反向\n-R乱序\n-t分隔符, -k\n-n按数值\n\nuniq §\n\n-c计数\n-d只输出重复\n-u只输出不重复\n-i忽略大小写\n-f跳过前n个域\n-s跳过前n个字符\n\nawk §\n\n\n\n$0当前行, $n第n个字段\n\n\n-F指定分隔符\n\n\n-f指定文件\n\n\n变量NF代表字段数\n\n\n变量NR代表当前行数\n\n\n{}字符串使用双引号\ncat /etc/passwd | head -n 5 | awk -F &#039;:&#039; &#039;{print $1&quot;, &quot;$2}&#039;\n\n\n\ntoupper(), tolower()\n\n\n条件\ncat /etc/passwd | awk -F &#039;:&#039; &#039;NR % 2 == 1 {print $1}&#039;\n\n\ntr §\n\n\n\n字符集1 替换为 字符集2\ncat words.txt | tr -s &#039; &#039; &#039;\\n&#039;\n\n\nEXAMPLES §\n重复次数最多的5条命令 §\n\n注意使用 -n 按数值排序\n\nhistory | awk {&#039;print $2&#039;} | sort | uniq -c | sort -nr -k1,1 | head -n 5\n192. Word Frequency §\nDifficulty: Medium\nWrite a bash script to calculate the frequency of each word in a text file words.txt.\nFor simplicity sake, you may assume:\n\nwords.txt contains only lowercase characters and space &#039; &#039; characters.\nEach word must consist of lowercase characters only.\nWords are separated by one or more whitespace characters.\n\nExample:\nAssume that words.txt has the following content:\nthe day is sunny the the\nthe sunny is is\n\nYour script should output the following, sorted by descending frequency:\nthe 4\nis 3\nsunny 2\nday 1\n\nNote:\n\nDon’t worry about handling ties, it is guaranteed that each word’s frequency count is unique.\nCould you write it in one-line using ?\n\nSolution §\nLanguage: Bash\n# Read from the file words.txt and output the word frequency list to stdout.\ncat words.txt | tr -s &#039; &#039; &#039;\\n&#039; | sort | uniq -c | sort -nr -k 1,1 | awk &#039;{print $2&quot; &quot;$1}&#039;\n193. Valid Phone Numbers §\nDifficulty: Easy\nGiven a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.\nYou may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)\nYou may also assume each line in the text file must not contain leading or trailing white spaces.\nExample:\nAssume that file.txt has the following content:\n987-123-4567\n123 456 7890\n(123) 456-7890\n\nYour script should output the following valid phone numbers:\n987-123-4567\n(123) 456-7890\n\nSolution §\nLanguage: Bash\n# Read from the file file.txt and output all valid phone numbers to stdout.\n \n \ncat file.txt | awk &#039;/^[0-9][0-9][0-9]\\-[0-9][0-9][0-9]\\-[0-9][0-9][0-9][0-9]$/ || /^\\([0-9][0-9][0-9]\\) [0-9][0-9][0-9]\\-[0-9][0-9][0-9][0-9]$/ {print $0}&#039;\n磁盘管理 §\natime, mtime, ctime §\n\nAccess: cat, more, less\nModify\nChange\n只Change, 不Modify的情况: mv, chrown\n\n/etc/passwd §\n\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n\n\n进程管理 §\nps §\n\na: show processes for all users\nu: display the process’s owner\nx: also show processes not attached to a terminal\n\nkill §\n\n-1, HUP: 中断终端\n-2, ctrl + c\n-9, KILL:强制终止\n-18, CONT: 继续, 与19相反\n-19, STOP, ctrl + z\n\n网络 §\ntcpdump §\n\nnetstat §\n\n\n-a: 包含LISTEN的\n-t: tcp\n-u: udp\n-l: 只包含LISTEN\n-s: 各种协议的统计信息\n-p: 显示连线的进程使用\n-n: 不要解析dns\n-c: 隔一秒输出一次\n\nlsof §\n\nLinux 一切皆文件\n\n\n-u: 某个用户打开的文件信息\n\n\n-c: 某个程序打开的文件信息\n\n\n-i: 网络连接\n\n\n所有的tcp\nlsof -i tcp\n\n\n:3306: 按端口查找\nlsof -i :3306\n\n\n\n\n-p: 通过进程号查找\n\n\nnc §\n\n\n-n: 不适用dns, 直接使用ip\n-u: 扫描udp, 默认是tcp\n\ntcpdump §\n\n\n\n监听指定的host\ntcpdump host 210.27.48.1\n\n\n监听本机udp且端口为123\ntcpdump udp port 123\n\n\ntelnet §\n\n\n查看端口是否开放\ntelnet chunibyo.xyz 22\n\n\nwhois §\n\n\n查看域名信息\nwhois chunibyo.xyz\n\n\ntraceroute §\ntraceroute www.baidu.com\n\n-m限制跳数\n\nmtr §\nping+traceroute\niptables §\n\n4个表\n\nnat(状态转换表)\nfilter(数据过滤表)\nraw(状态跟踪表)\nmangle(包标记表)\n\n\n内置链\n\ninput(入站)\noutput(出站)\nforward(转发)\nprerouting(路由前)\npostrouting(路由后)\n\n\n-t: 指定表名-t filter\n-A: 给链追加  规则-A INPUT\n-p: 指定协议名-p tcp\n-j: option -j DROP\n--dport: 指定端口 --dport 8081\n\n\n\n\n重置已有规则\niptables -X\n\n\n拒绝所有input流量\niptables -P INPUT DROP\n\n\nDNAT(Destination Network Address Translation): 目的地址转换\n\n\nSNAT(Source Network Address Translation)： 源地址转换\n\n\n怕其他 §\ngdb §\n\ng++ -g: Produce debugging information in the operating system’s native format (stabs, COFF, XCOFF, or DWARF).  GDB can work with this debugging information.\nrun: r 断点处停止\nnext: 单步运行, 不进入函数\nstep: 单步运行, 进入函数\nbreak/delete n: 第n行设置/删除断点\nenable/disable n: 第n行开启/暂停断点\nlist\nprint\nwatch: 监视的表达式值变化, 停止程序\n\n二、主机规划与磁盘分区 §\n2.2 磁盘分区 §\n磁盘(按照政策顺序) /dev/sd[a-p]\n分区: primary, extend\nMBR(master boot recoder): 主要开机记录区, 安装开机管理程序的地方\n2.2.3 BIOS 和 UEFI §\n固件: 写到硬件上的一个软件程序\nBIOS: 计算机主动执行的第一个程序\n开机到操作系统前的流程:\n\nBIOS：开机主动执行的固件，会认识第一个可开机的设备；\nMBR：第一个可开机设备的第一个扇区内的主要开机记录区块，内含开机管理程序；\n开机管理程序（boot loader）：一支可读取核心文件来执行的软件；\n核心文件：开始操作系统的功能…\n\n2.2.4 挂载 §\n\n五、Linux文件权限与目录配置 §\n5.1使用者与群组 §\n5.2Linux文件权限概念 §\n5.2.1 Linux文件属性 §\n\n\n文件拥有者可具备的权限\n加入此群组之帐号的权限\n非本人且没有加入本群组之其他帐号的权限\n\n5.2.2 改变文件属性和权限 §\n\n\nchgrp: 改变文件所属群组\nchgrp [group name] [file name]\n\n\nchown: 改变文件拥有者\nchown [user name]:[group name] [file name]\n\n\nchmod: 改变文件权限\n\nu,g,o三种身份权限\n+（加入） -（除去） =（设置）\n\n\n\n5.2.3 权限对目录的意义 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n内容rwx文件详细数据读文件内容写文件内容执行文件内容目录文件名读文件名修改文件名进入该目录的权限\n5.3 目录配置 §\n5.3.1 Filesystem Hierarchy Stantard §\n可分享的，不可分享的，不变的，可变的\n根目录(/)所在分区越小越好，且应用程序安装的软件最好不要与根目录放在同一个分区内\n\n/bin: 单人维护模式下还能执行的命令\n/boot:\n\nLinux核心文件\n开机菜单\n开机所需配置文件\n\n\n/dev: 外设\n/etc: 系统配置文件\n\n/etc/modprobe.d/模块装载时的配置文件\n/etc/passwd\n/etc/fstab系统挂载\n\n\n/lib:\n\n开机使用的函数库\n/bin和/sbin指令调用的函数库\n\n\n/media: 媒体\n/mnt: 暂时挂载额外设备\n/opt: 第三方协力软件\n/run: 开机后所产生的各项信息\n/sbin: 开机过程需要的，包括了开机、修复和还原系统需要的指令\n/srv: service缩写，网络服务启动后的数据目录，比如WWW，FTP\n/usr: Unix操作系统软件资源，可分享的和不可变动的FHS建议\n所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。\n\n/usr/bin: 系统可执行命令的主要目录\n/usr/lib:\n/usr/local: 自行安装, 非distribution默认\n/usr/sbin: 非系统正常运行需要的指令\n/usr/share\n\n\n/var: 主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file,run file），或者例如MySQL数据库的文件\n\n/var/cache: 程序本身运行过程中的暂存盘\n/var/lib: 程序执行过程中需要用到的数据文件放置目录\n/var/lock: 确保某些文件或者硬件只会给单一软件使用\n/var/log: 登陆文件目录\n\n/var/log/wtmp: last命令\n\n\n/var/run: 程序和服务的PID\n\n\n/home\n/liv64: 与/lib不同格式的二进制函数库\n/root: 系统管理员的主文件夹\n/lost+found\n/proc: 虚拟文件系统，放置的数据在内存中\n\n/proc/cpuinfo\n/proc/interrupts: 中断\n/proc/meminfo\n/proc/swaps\n/proc/version: 内核版本\n/proc/mounts\n\n\n/sys\n\n5.3.2 目录树 §\n\n六、Linux文件与目录管理 §\n\npwd -P: 显示确实的路径，也就是link目录的原目录\n\nmkdir -m 711 test2: 设置文件权限\n\n"},"Y-存档/A-工程项目/Linux/Terraria":{"title":"Terraria","links":[],"tags":["game","linux"],"content":"\n\nVanilla Server §\nDownloads §\n\nStart Dedicated Server §\n\nMake sure the script and program files have execute permissions by using the command chmod u+x TerrariaServer*(注意这里是通配符)\nSince the server will stop if the terminal session is ended, you can use a program like tmux or screen to keep the session running while you are logged out.\n\nSetting up dedicated server with configuration file §\n./TerrariaServer -config &lt;serverconfigfile&gt;\nMaking a configuration file §\n#this is an example config file for TerrariaServer.exe\n#use the command &#039;TerrariaServer.exe -config serverconfig.txt&#039; to use this configuration or run start-server.bat\n#please report crashes by emailing crashlog.txt to support@terraria.org\n\n#the following is a list of available command line parameters:\n\n#-config &lt;config file&gt;                          Specifies the configuration file to use.\n#-port &lt;port number&gt;                              Specifies the port to listen on.\n#-players &lt;number&gt; / -maxplayers &lt;number&gt;   Sets the max number of players\n#-pass &lt;password&gt; / -password &lt;password&gt;    Sets the server password\n#-world &lt;world file&gt;                              Load a world and automatically start the server.\n#-autocreate &lt;#&gt;                                Creates a world if none is found in the path specified by -world. World size is specified by: 1(small), 2(medium), and 3(large).\n#-banlist &lt;path&gt;                                Specifies the location of the banlist. Defaults to &quot;banlist.txt&quot; in the working directory.\n#-worldname &lt;world name&gt;                        Sets the name of the world when using -autocreate.\n#-secure                                            Adds addition cheat protection to the server.\n#-noupnp                                            Disables automatic port forwarding\n#-steam                                             Enables Steam Support\n#-lobby &lt;friends&gt; or &lt;private&gt;             Allows friends to join the server or sets it to private if Steam is enabled\n#-ip &lt;ip address&gt;   Sets the IP address for the server to listen on\n#-forcepriority &lt;priority&gt;  Sets the process priority for this task. If this is used the &quot;priority&quot; setting below will be ignored.\n\n#remove the # in front of commands to enable them.\n\n#Load a world and automatically start the server.\nworld=/root/.local/share/Terraria/Worlds/test2.wld\n\n#Creates a new world if none is found. World size is specified by: 1(small), 2(medium), and 3(large).\nautocreate=2\n\n#Sets the name of the world when using autocreate\nworldname=test2\n\n#Sets the difficulty of the world when using autocreate 0(normal), 1(expert)\ndifficulty=0\n\n#Sets the max number of players allowed on a server.  Value must be between 1 and 255\nmaxplayers=6\n\n#Set the port number\nport=7777\n\n#Set the server password\npassword=foo\n\n#Set the message of the day\nmotd=Please dont cut the purple trees!\n\n#Sets the folder where world files will be stored\nworldpath=/root/.local/share/Terraria/Worlds\n\n#The location of the banlist. Defaults to &quot;banlist.txt&quot; in the working directory.\nbanlist=banlist.txt\n\n#Adds addition cheat protection.\nsecure=1\n\n#Sets the server language 1:English, 2:German, 3:Italian, 4:French, 5:Spanish\nlang=1\n\n#Automatically forward ports with uPNP\n#upnp=1\n\n#Reduces enemy skipping but increases bandwidth usage. The lower the number the less skipping will happen, but more data is sent. 0 is off.\n#npcstream=60\n\n#Default system priority 0:Realtime, 1:High, 2:AboveNormal, 3:Normal, 4:BelowNormal, 5:Idle\npriority=1\n\nWorld File Location §\n~/.local/share/Terraria/Worlds\n生成service §\n# /lib/systemd/system/terraria.service\n[Unit]\nDescription=server daemon for terraria\n\n[Service]\nType=forking\nUser=root\nKillMode=none\nExecStart=/usr/bin/screen -dmS terraria /bin/bash -c &quot;/root/terraria/TerrariaServer.bin.x86_64 -config /root/terraria/serverconfig.txt 2&gt;&amp;1 | tee /root/log_ws/terraria.log&quot;\nExecStop=/usr/local/bin/terrariad exit\n\n[Install]\nWantedBy=multi-user.target\n\n#!/bin/bash\n# /usr/local/bin/terrariad\n\nsend=&quot;`printf \\&quot;$*\\r\\&quot;`&quot;\nattach=&quot;screen -r terraria&quot;\ninject=&quot;screen -S terraria -X stuff $send&quot;\n\nif [ &quot;$1&quot; = &quot;attach&quot; ] ;\nthen\n    cmd=&quot;$attach&quot; ;\nelse\n    cmd=&quot;$inject&quot; ;\nfi\n\n$cmd\n\nsystemctl start terraria.service\nterrariad &lt;command&gt;\nterrariad attach\n\n$ systemctl status terraria.service\n● terraria.service - server daemon for terraria\n   Loaded: loaded (/lib/systemd/system/terraria.service; enabled; vendor preset: enabled)\n   Active: active (running) since Sun 2020-02-09 20:46:51 CST; 2h 2min ago\n Main PID: 369 (screen)\n    Tasks: 10 (limit: 4680)\n   CGroup: /system.slice/terraria.service\n           ├─369 /usr/bin/SCREEN -dmS terraria /bin/bash -c /root/terraria/TerrariaServer.bin.x86_64 -config           ├─397 /bin/bash -c /root/terraria/TerrariaServer.bin.x86_64 -config /root/terraria/serverconfig.t           ├─409 /root/terraria/TerrariaServer.bin.x86_64 -config /root/terraria/serverconfig.txt\n           └─410 tee /root/log_ws/terraria.log\n\nFeb 09 20:46:51 iZbp13dkrvca9v6gpgqk8zZ systemd[1]: Starting server daemon for terraria...\nFeb 09 20:46:51 iZbp13dkrvca9v6gpgqk8zZ systemd[1]: Started server daemon for terraria.\nlines 1-13/13 (END)\n\ntModLoaderServer §\nDownloads §\n\n使用 §\n\n\n解压之后全部mv进terraria的工作空间\n\n\n\n修改serverconfig.txt\n#this is an example config file for TerrariaServer.exe\n#use the command &#039;TerrariaServer.exe -config serverconfig.txt&#039; to use this configuration or run start-server.bat\n#please report crashes by emailing crashlog.txt to support@terraria.org\n\n#the following is a list of available command line parameters:\n\n#-config &lt;config file&gt;                          Specifies the configuration file to use.\n#-port &lt;port number&gt;                              Specifies the port to listen on.\n#-players &lt;number&gt; / -maxplayers &lt;number&gt;   Sets the max number of players\n#-pass &lt;password&gt; / -password &lt;password&gt;    Sets the server password\n#-world &lt;world file&gt;                              Load a world and automatically start the server.\n#-autocreate &lt;#&gt;                                Creates a world if none is found in the path specified by -world. World size is specified by: 1(small), 2(medium), and 3(large).\n#-banlist &lt;path&gt;                                Specifies the location of the banlist. Defaults to &quot;banlist.txt&quot; in the working directory.\n#-worldname &lt;world name&gt;                        Sets the name of the world when using -autocreate.\n#-secure                                            Adds addition cheat protection to the server.\n#-noupnp                                            Disables automatic port forwarding\n#-steam                                             Enables Steam Support\n#-lobby &lt;friends&gt; or &lt;private&gt;             Allows friends to join the server or sets it to private if Steam is enabled\n#-ip &lt;ip address&gt;   Sets the IP address for the server to listen on\n#-forcepriority &lt;priority&gt;  Sets the process priority for this task. If this is used the &quot;priority&quot; setting below will be ignored.\n\n#remove the # in front of commands to enable them.\n\n#Load a world and automatically start the server.\nworld=/root/.local/share/Terraria/ModLoader/Worlds/AccelWorld.wld\n\n#Creates a new world if none is found. World size is specified by: 1(small), 2(medium), and 3(large).       autocreate=3\n\n#Sets the name of the world when using autocreate\nworldname=AccelWorld\n\n#Sets the difficulty of the world when using autocreate 0(normal), 1(expert)\ndifficulty=0\n\n#Sets the max number of players allowed on a server.  Value must be between 1 and 255\nmaxplayers=4\n\n#Set the port number\nport=7777\n\n#Set the server password\n#password=\n\n#Set the message of the day\nmotd=少年, 你想不想...&quot;加速&quot;到更快的境界?\n\n#Sets the folder where world files will be stored\nworldpath=/root/.local/share/Terraria/ModLoader/Worlds\n\n#The location of the banlist. Defaults to &quot;banlist.txt&quot; in the working directory.\nbanlist=banlist.txt\n\n#Adds addition cheat protection.\nsecure=1\n\n#Sets the server language 1:English, 2:German, 3:Italian, 4:French, 5:Spanish\nlang=1\n\n#Automatically forward ports with uPNP\n#upnp=1\n\n#Reduces enemy skipping but increases bandwidth usage. The lower the number the less skipping will happen, but more data is sent. 0 is off.\n#npcstream=60\n\n#Default system priority 0:Realtime, 1:High, 2:AboveNormal, 3:Normal, 4:BelowNormal, 5:Idle\npriority=1\n\n\n\n修改terraria.service\n[Unit]\nDescription=[泰拉瑞亚]service\n\n[Service]\nType=forking\nUser=root\nKillMode=none\nExecStart=/usr/bin/screen -dmS terraria /bin/bash -c &quot;/root/terraria/tModLoaderServer.bin.x86_64 -config /root/terraria/serverconfig.txt 2&gt;&amp;1 | tee /root/log_ws/terraria.log&quot;\nExecStop=/usr/local/bin/terrariad exit\n\n[Install]\nWantedBy=multi-user.target\n\n\n\nWorlds &amp; Mods §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称位置vanilla worlds~/.local/share/Terraria/Worlds/mod worlds~/.local/share/Terraria/ModLoader/Worlds/mod mods~/.local/share/Terraria/ModLoader/Mods/"},"Y-存档/A-工程项目/Linux/proc记录":{"title":"proc记录","links":[],"tags":["linux"],"content":"\n\n1. /proc/meminfo §\n  Ubuntu [21:24:03] ~\n$ cat /proc/m\nmdstat   meminfo  misc     modules  mounts   mtrr\n  Ubuntu [21:24:03] ~\n$ cat /proc/meminfo\nMemTotal:        4039176 kB\nMemFree:         2055004 kB\nMemAvailable:    2138952 kB\nBuffers:           22528 kB\nCached:           243984 kB\nSwapCached:        59464 kB\nActive:          1284028 kB\nInactive:         560252 kB\nActive(anon):    1099636 kB\nInactive(anon):   474752 kB\nActive(file):     184392 kB\nInactive(file):    85500 kB\nUnevictable:           0 kB\nMlocked:               0 kB\nSwapTotal:        969964 kB\nSwapFree:         579308 kB\nDirty:                56 kB\nWriteback:             0 kB\nAnonPages:       1551440 kB\nMapped:            69568 kB\nShmem:                84 kB\nSlab:              82848 kB\nSReclaimable:      37660 kB\nSUnreclaim:        45188 kB\nKernelStack:        4192 kB\nPageTables:         9644 kB\nNFS_Unstable:          0 kB\nBounce:                0 kB\nWritebackTmp:          0 kB\nCommitLimit:     2989552 kB\nCommitted_AS:    3738756 kB\nVmallocTotal:   34359738367 kB\nVmallocUsed:           0 kB\nVmallocChunk:          0 kB\nHardwareCorrupted:     0 kB\nAnonHugePages:         0 kB\nShmemHugePages:        0 kB\nShmemPmdMapped:        0 kB\nCmaTotal:              0 kB\nCmaFree:               0 kB\nHugePages_Total:       0\nHugePages_Free:        0\nHugePages_Rsvd:        0\nHugePages_Surp:        0\nHugepagesize:       2048 kB\nDirectMap4k:      663424 kB\nDirectMap2M:     3530752 kB\nDirectMap1G:     2097152 kB\n\n\nMemFree\nMemAvailable: 在不使用交换空间的情况下，启动一个应用可用的最大内存\nBuffers\nCached\nPageTables: 内存页页面大小\n\n实际可以挪用的内存数为free+cache+buffer\n实际使用的内存数为used-cache-buffer(total-free-cache-buffer),\n2. /proc/cpuinfo §\nprocessor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 85\nmodel name\t: Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz\nstepping\t: 4\nmicrocode\t: 0x1\ncpu MHz\t\t: 2500.014\ncache size\t: 33792 KB\nphysical id\t: 0\nsiblings\t: 2\ncore id\t\t: 0\ncpu cores\t: 1\napicid\t\t: 0\ninitial apicid\t: 0\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 13\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti ibrs ibpb stibp fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1\nbugs\t\t: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihit\nbogomips\t: 5000.02\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 46 bits physical, 48 bits virtual\npower management:\n\nprocessor\t: 1\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 85\nmodel name\t: Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz\nstepping\t: 4\nmicrocode\t: 0x1\ncpu MHz\t\t: 2500.014\ncache size\t: 33792 KB\nphysical id\t: 0\nsiblings\t: 2\ncore id\t\t: 0\ncpu cores\t: 1\napicid\t\t: 1\ninitial apicid\t: 1\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 13\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti ibrs ibpb stibp fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1\nbugs\t\t: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihit\nbogomips\t: 5000.02\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 46 bits physical, 48 bits virtual\npower management:\n"},"Y-存档/A-工程项目/前端/js-request":{"title":"Http请求","links":[],"tags":["前端"],"content":"\n\n1. Http的参数 §\n1.1 URL放入参数 §\nhttp://{{host}}:{{port}}/api/file_list?path=/\n\n\nvar settings = {\n    &quot;url&quot;: &quot;http://localhost:8888/api/url?KEY=VALUE&quot;,\n    &quot;method&quot;: &quot;GET&quot;,\n    &quot;timeout&quot;: 0,\n};\n \n$.ajax(settings).done(function (response) {\n    console.log(response);\n});\n@app.route(&#039;/api/url&#039;, methods=[&#039;GET&#039;])\ndef get_url():\n    return request.args.get(&quot;KEY&quot;)\n1.2 Body放入参数 §\n1.2.1 text/plain文本传输 §\nContent-type: text/plain\n\nvar settings = {\n    &quot;url&quot;: &quot;http://localhost:8888/api/textplain&quot;,\n    &quot;method&quot;: &quot;GET&quot;,\n    &quot;timeout&quot;: 0,\n    &quot;headers&quot;: {\n        &quot;Content-Type&quot;: &quot;text/plain&quot;\n    },\n    &quot;data&quot;: &quot;textplain\\ndata\\ntest&quot;,\n};\n \n$.ajax(settings).done(function (response) {\n    console.log(response);\n});\n@app.route(&#039;/api/textplain&#039;, methods=[&#039;GET&#039;])\ndef get_textplain():\n    return request.data\n1.2.2 application参数传输 §\n1.2.2.1 Form表单 §\nContent-type: application/x-www-form-urlencoded\n\nvar settings = {\n    &quot;url&quot;: &quot;http://localhost:8888/api/form&quot;,\n    &quot;method&quot;: &quot;GET&quot;,\n    &quot;timeout&quot;: 0,\n    &quot;headers&quot;: {\n        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;\n    },\n    &quot;data&quot;: {\n        &quot;KEY&quot;: &quot;VALUE&quot;\n    }\n};\n \n$.ajax(settings).done(function (response) {\n    console.log(response);\n});\n@app.route(&#039;/api/form&#039;, methods=[&#039;GET&#039;])\ndef get_form():\n    return request.form[&quot;KEY&quot;]\n1.2.2.2 JSON Object §\n\nvar settings = {\n    &quot;url&quot;: &quot;http://localhost:8888/api/json&quot;,\n    &quot;method&quot;: &quot;GET&quot;,\n    &quot;timeout&quot;: 0,\n    &quot;headers&quot;: {\n        &quot;Content-Type&quot;: &quot;application/json&quot;\n    },\n    &quot;data&quot;: JSON.stringify({&quot;KEY&quot;:&quot;VALUE&quot;}),\n};\n \n$.ajax(settings).done(function (response) {\n    console.log(response);\n});\n@app.route(&#039;/api/json&#039;, methods=[&#039;GET&#039;])\ndef get_json():\n    return request.json[&quot;KEY&quot;]\n1.3 总结 §\n通常情况下x-www-form-urlencoded是最常用的传参方法\n2. 测试方法 §\n2.1 后端 §\npostman 如上\n2.2 前端 §\npostman mock server + fiddler"},"Y-存档/A-工程项目/数据库/MySQL":{"title":"MySQL复习","links":[],"tags":["mysql"],"content":"\n\n1. 事务 §\n满足ACID的一组操作, 使用Commit和Rollback操作\nMySQLd 每个查询都是AUTOCOMMIT\n\nAtomicity(原子性): 全部成功，要么全部失败\nConsistency(一致性): AB两账户无论转账, 总额不会改变\nIsolation(隔离性): 多个用户并发访问数据库时, 多个并发事务之间相互隔离\nDurability(持久性): 一旦事务提交，则其所做的修改将会永远保存到数据库中\n\n\n二. 范式 §\n一般满足3NF足够\n\n1NF: 属性不可分\n2NF: 属性完全依赖于主键(消除部分子函数依赖)\n3NF: 属性不依赖于其他非主属性(消除传递依赖)\nBCNF: 任何非主属性不能对主键子集依赖[消除对主码子集的依赖]\n\n三. 锁🔒 §\n1. 共享锁与排他锁 §\n\n共享锁: 多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n排他锁: 不能与其他所并存, 但是获取排他锁的事务是可以对数据就行读取和修改。\nupdate,delete,insert都会自动加上排他锁\nselect语句默认不会加任何锁, 并且直接select不存在锁限制\nselect\n\n加共享锁: select ... lock in share mode\n加排他锁: select ...for update\n\n\n\n2. 悲观锁与乐观锁 §\n悲观锁和乐观锁都是业务逻辑层次的定义，不同的设计可能会有不同的实现。\n\n\n在mysql层常用的悲观锁实现方式是加一个排他锁。\nbegin;\nselect * from account where id = 1 for update;\nupdate account set balance=150 where id =1;\ncommit;\n\n\n乐观锁是指在获取数据时候不加锁，乐观的认为操作不会有冲突，在update的时候再去检查冲突。\nbegin;\nselect balance from account where id=1;\n-- 得到balance=100;然后计算balance=100+50=150\nupdate account set balance = 150 where id=1 and balance = 100;\ncommit;\n\n\n四. 并发一致性 §\n1. 丢失修改 §\n解决办法: 事务+查询共享锁\n\n2. 脏读 §\n解决办法:\n\n把数据库的事务隔离级别调整到 READ_COMMITTED\n共享锁select\n\n\n3. 不可重复读 §\n解决办法:\n\n数据库的事务隔离级别调整到REPEATABLE_READ\nselect共享锁\n\n\n4. 幻读 §\n\n五. 数据类型 §\n1. 整形 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTinyintsmallintmediumintintbigintbit1*82*83*84*88*8\n2. 浮点型 §\nFLOAT, DOUBLE(浮点类型)\nDECIMAL(高精度小数类型, CPU不原生支持)\n3. 字符串 §\nCHAR, VARCHAR\n4. 时间和日期 §\n\nDATETIME(8字节)“2008-01-16 22:37:08”\nTIMESTAMP(4字节), 与时区有关\n\n六. 索引 §\n\n对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。\n对于中到大型的表，索引就非常有效。\n但是对于特大型的表，建立和维护索引的代价将会随之增长。\n需要用到一种技术可以直接区分出需要查询的一组数据\n而不是一条记录一条记录地匹配，例如可以使用分区技术。\n\n不同存储引擎具有不同的索引类型和实现\n1. B-Tree §\n常用命令 §\n\n\nuser, host字段在mysql.user表里\nselect user, host from mysql.user;\n\n\n赋权\ngrant select on practice.* to &#039;chunibyo&#039;@&#039;%&#039;;\nflush privileges\n\n\n有用户切换了他们的ip地址\nRENAME USER user@ipaddress1 TO user@ipaddress2;\t\n\n\n查看当前使用数据库\nselect database();\n查看所有数据库\nshow databases;\n\n\n格式化日期\nselect date_format(now(), &#039;%y-%m-%d %H:%i:%s&#039;);\n\n\n事务\nbegin;\nXXXXX\ncommit; / rollback;\n\n\nalter\n删除teacher表name字段\nalter table teacher drop name;\n\n添加teacher表name字段\nalter table teacher add name INT;\n\nalter table teacher modify name char(10);\n\n\nUNION\nSELECT customerNumber\nFROM orders\nUNION ALL\nSELECT customerNumber\nFROM payments\n默认distinct\n\n\nGROUP BY\n根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。\n\n\nJOIN\n\n\nINNER JOIN\nSELECT *\nFROM productlines\n         INNER JOIN products on productlines.productLine = products.productLine;\n\n\nLEFT JOIN\n\n\nRIGHT JOIN\n\n\n\n\nNULL\n# 正确\nSELECT *\nFROM productlines\nWHERE htmlDescription IS NULL;\n\n# 错误\nSELECT *\nFROM productlines\nWHERE htmlDescription = NULL;\n\n\nsql 50题 §\n\n\n查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数\n\n\n查询同时存在” 01 “课程和” 02 “课程的情况\nselect *\nfrom (select SId from SC where SC.CId = &#039;01&#039;) as t1,\n     (select SId from SC where SC.Cid = &#039;02&#039;) as t2\nwhere t1.SId = t2.SId;\n\n\n\n查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )\nselect t1.SId, t1.CId, t2.CId\nfrom (select * from SC where CId = &#039;01&#039;) as t1\n         left join\n         (select * from SC where CId = &#039;02&#039;) as t2\n         on t1.SId = t2.SId;\n\n\n\n查询各科成绩最高分、最低分和平均分\n# 14\nselect SC.CId,\n       max(SC.score)                                              as max_score,\n       min(SC.score)                                              as min_score,\n       AVG(SC.score)                                              as avg_score,\n       count(*)                                                   as number,\n       sum(IF(SC.score &gt;= 60, 1, 0)) / count(*)                   as D,\n       sum(IF(SC.score &gt;= 70 and SC.score &lt; 80, 1, 0)) / count(*) as C,\n       sum(IF(SC.score &gt;= 80 and SC.score &lt; 90, 1, 0)) / count(*) as B,\n       sum(IF(SC.score &gt;= 90, 1, 0)) / count(*)                   as A\nfrom SC\nGROUP BY SC.CId\nORDER BY count(*) DESC, SC.CId\n\n\n\n各科成绩进行排序，并显示排名， Score 重复时保留名次空缺\n# 15\nselect a.CId, a.SId, a.score, count(b.CId) + 1 as _rank\nfrom SC as a\n         left join SC as b\n                   on a.CId = b.CId and a.score &lt; b.score\ngroup by a.CId, a.SId, a.score\norder by a.CId ASC, a.score DESC\n\n\n\n查询学生的总成绩，并进行排名，总分重复时不保留名次空缺\n\n"},"Y-存档/A-工程项目/数据库/Redis设计与实现":{"title":"Redis设计与实现","links":[],"tags":["redis"],"content":"\n\n命令 §\n一、string §\nset, get, del, mset, mget\n二、hash §\nhset h1 name liming\nhdel h1 age\n三、list §\nlrange, lpop\n四、set §\nsadd， smembers\n一、数据结构与对象 §\n第二章、简单动态字符串(SDS) §\nsimple dynamic string\nstruct sdshdr {\n    // buf数组使用字节的数量\n    int len;\n    \n    // buf数组未使用字节的数量\n    int free;\n    \n    // 字节数组，用于保存字符串\n    char buf[];\n};\n第三章、链表 §\n链表键、发布与订阅、慢查询和监视器\ntypedef struct ListNode {\n    struct ListNode *prev;\n    struct ListNode *next;\n    void *value;\n    \n}ListNode;\n \ntypedef struct List {\n    ListNode* head;\n    ListNode* tail;\n    unsigned long len;\n    \n    // 节点值复制函数\n    void *(*dup)  (void *ptr);\n    \n    // 节点值释放函数\n    void  (*free) (void *ptr);\n    \n    // 节点值对比函数\n    int   (*match)(void *ptr);\n}List;\n8465656\n第四章、字典 §\n4.1 哈希表 §\ntypedef struct dictht {\n    // 哈希表数组\n    dictEntry **table;\n    \n    // 哈希表大小\n    unsigned long size;\n    \n    // 用于计算索引值, 等于 size-1\n    unsigned long sizemask;\n    \n    // 哈希表节点数目\n    unsigned long used;\n}dictht;\n4.2 哈希表节点 §\ntypedef struct dictEntry {\n    // 键\n    void *key;\n    \n    // 值\n    union z{\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    \n    // 指向下一个哈希表节点\n    struct dictEntry *next;\n}dictEntry;\n4.3 字典 §\ntypedef struct dict {\n    // 类型特定函数\n    dictType *type;\n    \n    // 私有数据\n    void *privdata;\n    \n    // 哈希表\n    dictht ht[2];\n    \n    // rehash索引\n    int trehashidx;\n}dict;\n4.4 哈希算法 §\n\nhash   = dict-&gt;type-&gt;MurmurHash2(key)\nindex = hash &amp; dict-&gt;ht[0].sizemask;\n\n4.5 rehash §\n\nht[0] 渐进式 rehash 到 ht[1]\n释放 ht[0]\nht[1] 设置为 ht[0], 给 ht[1] 分配一个空白哈希表\n\n第五章、跳跃表 §\n有序集合的底层实现之一（另一个是字典）\nzskiplist， zskiplistNode\n随机算法\n第六章、整数集合 §\ntypefef struct intest {\n    // int16_t, int32_t, int64_t\n    uint32_t encoding;\n    \n    uint32_t length;\n    \n    int8_t contents[];\n}\n升级， 无法降级\n第七章、压缩列表 §\n连续内存\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n属性长度(字节)用途zlbytes4总字节数zltail4表尾节点的偏移zllen2节点数(不能太多)entryX节点zlend1特殊值0xFF\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n描述previous_entry_lengthencoding数据类型及长度content\n连锁更新"},"Y-存档/A-工程项目/语法/cpp":{"title":"c++复习","links":[],"tags":[],"content":"\n\nnew和malloc §\n\n\nnew从自由存储区分配内存空间\nmalloc从堆上分配内存空间\n\n\nnew返回对象类型指针\nmalloc返回void *, 需要强制转化\n\n\nnew内存分配失败抛出bac_alloc异常, 不会返回NULL\nmalloc失败时返回NULL\nint *a  = (int *)malloc (sizeof (int ));\nif(NULL == a)\n{\n    ...\n}\nelse \n{\n    ...\n}\n \ntry\n{\n    int *a = new int();\n}\ncatch (bad_alloc)\n{\n    ...\n}\n\n\nmalloc需要显示指定类型大小malloc(sizeof(int))\n\n\n构造/析构函数\n\nnew操作符\n\n调用operator new函数, 分配一块足够大的,原始的,未命名的内存空间以便存储特定类型的对象\n构造对象, 传入初值\n返回对象指针\n\n\ndelete操作符\n\n析构函数\noperator delete\n\n\n\n\n\n数组\n\nnew: A * ptr = new A[10];\nmalloc: int * ptr = (int *) malloc(sizeof(int)* 10);\n\n\n\noperator new的实现可以基于malloc\n\n\nopeartor new /operator delete可以被重载\n\n\nnew和delete §\n智能指针 §\nstd::auto_ptr&lt;report&gt; ps(new report(&quot;using auto ptr&quot;));\nps-&gt;comment();\nlambda §\n数据结构 §\nhttps://marian5211.github.io/2018/03/09/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81Trie%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/\nmap, set\n11 &amp; 14 &amp; 17 新特性 §\n11 §\n\nauto\n\n奇怪的笔试题~ §\n\n\nsizeof(class)\n#include &lt;iostream&gt;\n \n// 占位符\nclass A {\npublic:\n    A() = default;\n};\n \n// 一个虚表指针\nclass B {\n    void f1() {}\n \n    virtual void f2() {}\n};\n \n// 一个虚表指针\nclass C : public B {\n};\n \n// \nclass D {\n    int a;\n    char *p;\n};\n \nint main() {\n    printf(&quot;%lu\\n&quot;, sizeof(A));\n    printf(&quot;%lu\\n&quot;, sizeof(B));\n    printf(&quot;%lu\\n&quot;, sizeof(C));\n    printf(&quot;%lu\\n&quot;, sizeof(D));\n}\n​\t\t\n\n\n"},"Y-存档/A-工程项目/语法/java":{"title":"java基础","links":[],"tags":[],"content":"\n\n基础 §\n\n\n类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。\n\n\n访问控制修饰符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n当前类同一包子孙类(同一包)子孙类(不同包)其他包publicYYYYYprotectedYYYYdefaultYYYprivateY\n\n\n接口与抽象类\n接口和抽象类都是继承树的上层，他们的共同点如下：\n\n都是上层的抽象层。\n都不能被实例化\n都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。\n\n他们的区别如下：\n\n在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。\n一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。\n\n\n\nSpring §\n一、概述 §\n\nInverse of Control\nAspect Oriented Progamming\n\n\n二、IoC §\n控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。\n2.1 Bean的属性 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n属性描述classpackageName + classNameid/name唯一标识scope作用域constructor-argpropertiesautowiring modelazy-initialization延迟创建(启动时创建)initializationbean的所有必须属性被容器设置后调用的回调方法destructionbean被销毁时调用的回调方法\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;\n    \n    &lt;!-- A simple bean definition --&gt;\n    &lt;bean id=&quot;&quot; class=&quot;&quot; &gt;\n    \t&lt;!-- collaborators and configuration for this bean go here --&gt;\n    &lt;/bean&gt;\n    \n    &lt;!-- A bean definition with lazy init set on --&gt;\n    &lt;bean id=&quot;&quot; class=&quot;&quot; lazy-init=&quot;true&quot;&gt;\n    \t&lt;!-- collaborators and configuration for this bean go here --&gt;\n    &lt;/bean&gt;\n    \n    &lt;!-- A bean definition with initialization method --&gt;\n    &lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;...&quot; &gt;\n    \t&lt;!-- collaborators and configuration for this bean go here --&gt;\n    &lt;/bean&gt;\n    \n    &lt;!-- A bean definition with destruction method --&gt;\n    &lt;bean id=&quot;&quot; class=&quot;&quot; destroy-method=&quot;...&quot; &gt;\n    \t&lt;!-- collaborators and configuration for this bean go here --&gt;\n    &lt;/bean&gt;\n    \n    &lt;!-- more bean definitions go here --&gt;\n    \n&lt;/beans&gt;\n2.2 Bean的作用域 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用域描述singleton单例, 默认值prototype每次调用都产生新的实例request每次Http请求都会创建一个Bean, 仅作用于WebApplicationContext环境session同一个Http Session共用一个Bean, 仅作用于WebApplicationContext环境global-session一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境\n2.3 生命周期 §\n&lt;bean\n            id=&quot;hello&quot;\n            class=&quot;com.example.Hello&quot;\n            init-method=&quot;init&quot;\n            destroy-method=&quot;destroy&quot;&gt;\n        &lt;property name=&quot;msg&quot; value=&quot;这个msg属性的value&quot;/&gt;\n    &lt;/bean&gt;\nBean的销毁需要使用AbstractApplicationContext.registerShutdownHook()\n2.4 Bean的继承 §\n基于继承使用Bean模板\n&lt;bean id=&quot;beanTeamplate&quot; abstract=&quot;true&quot;&gt;\n      &lt;property name=&quot;message1&quot; value=&quot;Hello World!&quot;/&gt;\n      &lt;property name=&quot;message2&quot; value=&quot;Hello Second World!&quot;/&gt;\n      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;\n   &lt;/bean&gt;\n \n   &lt;bean id=&quot;helloIndia&quot; class=&quot;com.tutorialspoint.HelloIndia&quot; parent=&quot;beanTeamplate&quot;&gt;\n      &lt;property name=&quot;message1&quot; value=&quot;Hello India!&quot;/&gt;\n      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;\n   &lt;/bean&gt;\n三、依赖注入 §\n3.1 基于构造函数的依赖注入 §\n&lt;beans&gt;\n   &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;\n      &lt;constructor-arg index=&quot;0&quot; value=&quot;2001&quot;/&gt;\n      &lt;constructor-arg index=&quot;1&quot; value=&quot;Zara&quot;/&gt;\n   &lt;/bean&gt;\n&lt;/beans&gt;\n3.2 基于设值函数的依赖注入 §\n&lt;bean id=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;\n      &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;\n      &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;\n&lt;/bean&gt;\n3.3 @Autowired §\nSpringBoot §\n一、AOP §\n\n\n@Aspect：声明该类为一个注解类；\n\n\n@Pointcut：定义一个切点，后面跟随一个表达式，表达式可以定义为切某个注解，也可以切某个 package 下的方法\n\n\n@Before: 在切点之前，织入相关代码；\n\n\n@After: 在切点之后，织入相关代码;\n\n\n@AfterReturning: 在切点返回内容后，织入相关代码，一般用于对返回值做些加工处理的场景；\n\n\n@AfterThrowing: 用来处理当织入的代码抛出异常后的逻辑处理;\n\n\n@Around: 环绕，可以在切入点前后织入代码，并且可以自由的控制何时执行切点；\n\n\n"},"Y-存档/A-工程项目/面试/ComputerNetwork":{"title":"计算机网络复习","links":[],"tags":[],"content":"\n\n一. 传输层 §\n1. OSI TCP/IP §\nOSI: 应表会 传 网 数物\nTCP/IP: 应 传 网 网络接入\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据单位应用层用户接口应用程序报文运输层进程间通用数据传输服务TCP报文段UDP用户数据报网络层主机, 路由器数据包数据链路层交换机帧物理层比特流\n2. UDP和TCP §\n用户数据报协议 UDP（User Datagram Protocol）\n无连接的，尽最大可能交付，没有拥塞控制\n面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）\n支持一对一、一对多、多对一和多对多的交互通信\n例如：视频传输、实时通信\n\n传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。\n\n\nseq: 序号\nack: 确认\nACK: 确认\n\n第一次client向server请求时ack=0\nTCP 规定, 在连接建立后所有传送的报文段都必须把 ACK 置 1\n\n\nsyn: 同步\n\nSYN=1，ACK=0: 连接请求报文段\nSYN=1，ACK=1: 对方同意建立连接\n\n\nFIN: 终止\n\n当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接\n四次挥手时会出现在第1, 3次共两次\n\n\n"},"Y-存档/A-工程项目/面试/OperatingSystem":{"title":"操作系统复习","links":[],"tags":[],"content":"\n\n一. 进程管理 §\n1. 进程同步 §\n同步, 互斥, pv操作\n管程(monitors): 结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。管程是为了解决信号量在临界区的 PV 操作上的配对的麻烦，把配对的 PV 操作集中在一起，生成的一种并发编程方法。其中使用了条件变量这种同步机制。\n2. 进程通信 §\n\n\n管道, fd[0]用于读, fd[1]用于写\n\n命名管道\n消息队列(可以独立于读写进程存在)\n信号量\n共享内存\n套接字\n\n3. 线程通信 §\n\nsynchronized同步\nwhile轮询的方式(浪费资源)\nwait/notify机制\n\n4. 进程操作 §\n进程 = 代码段 + 数据段 + PCB\n进程0: Linux引导中创建的第一个进程，完成加载系统后，演变为进程调度、交换及存储管理进程。\n进程1: init进程，由0进程创建，完成系统的初始化. 是系统中所有其它用户进程的祖先进程\n1. fork §\n#include &lt;unistd.h&gt;\n...\npid_t fork(void);\nfork() 可能會有以下三種回傳值：\n\n-1 ： 發生錯誤\n0 ： 代表為子程序\n大於 0 ： 代表為父程序, 其回傳值為子程序的 ProcessID\n\n5. 孤儿和僵尸进程 §\n孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为1）所收养，并由 init 进程对它们完成状态收集工作。\n僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。\n6. 守护进程(Daemon) §\n它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务\n系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld\n超级用户\n7. 协程 §\n从函数的角度看，\n\n协程避免了传统的函数调用栈，几乎可以无限递归。\n\n从线程的角度看，\n\n协程没有上下文切换，几乎可以无限并发\n协程在用户态进行显式的任务调度，可以把异步操作转换成同步操作，也意味着无需额外的加锁。\n\n8. 上下文切换 §\n\n\n二. 死锁 §\n\n面试官问你告诉我什么是死锁，我就录用你\n你回答面试官你录用我，我告诉你\n\n1. 死锁的条件 §\n\n互斥\n占有和等待\n不可抢占\n循环等待\n\n2. 解决 §\n\n\n三. 内存管理 §\n1. 虚拟内存 §\n让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存\n这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到一部分不在物理内存中的地址空间时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。\n2. 页面置换算法 §\n\n701203042\n\n\n\nOPT\n被换出的页面将是最长时间内不再被访问\n现实情况不存在\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n701203042177722222220000000031113344\n\n\nLRU, Least Recently Used\n当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面时最近最久未访问的\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n701203042170120304227012030437012230\n\n\nNRU, Not Recently Used\n访问位 + 修改位\n\n\nFIFO, First In First Out(二次机会)\n\n\nClock, fifo改成环形, 指针指向最老页面\n\n\n3. 内存管理 §\n\n进程的内存空间布局\n\n\n内核空间(大小一般固定)\n用户态的栈\nmmap(内存映射)\nbrk(堆): 由程序员分配释放\n栈: 临时变量, 函数参数\nBSS(Block Started By Symbol): 存放未初始化的局部变量, 变量使用前由运行时初始化为零\n数据段: 静态变量和已初始化且不为零的局部变量\n代码段: 可执行文件操作指令 , 只读, 运行前大小已知\n\n\n\n四. 设备管理 §\n1. 磁盘调度算法 §\n\n\nFCFS, First Come First Served\n\n\n\nSSTF, Shortest Seek Time First\n饥饿\n\n\n\nSCAN\n\n\n\n五. 链接 §\n六. Linux §"},"Y-存档/A-工程项目/面试/STL":{"title":"STL源码剖析","links":[],"tags":["cpp"],"content":"\n\n一、STL简介 §\n1.9 常见迷惑写法 §\n1.9.4 increment / decrement / dereference §\n#include&lt;iostream&gt;\n \nusing namespace std;\n \nclass INT {\n    friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const INT&amp; i);\npublic:\n    INT(int i) : m_i(i) {};\n \n    INT&amp; operator++() {\n        ++(this-&gt;m_i);\n        return *this;\n    }\n \n    const INT operator++(int) {\n        INT temp = *this;\n        ++(*this);\n        return temp;\n    }\n \n    INT&amp; operator--() {\n        --(this-&gt;m_i);\n        return *this;\n    }\n \n    const INT operator--(int) {\n        INT temp = *this;\n        --(*this);\n        return temp;\n    }\n \n    int&amp; operator*() const {\n        return (int &amp;)m_i;\n    }\nprivate:\n    int m_i;\n};\n \nostream&amp; operator&lt;&lt;(ostream&amp; os, const INT&amp; i) {\n    os &lt;&lt; &#039;{&#039; &lt;&lt; i.m_i &lt;&lt; &#039;}&#039;;\n    return os;\n}\n \n \nint main() {\n    INT I(5);\n    cout &lt;&lt; I++ &lt;&lt; endl;\n    cout &lt;&lt; ++I &lt;&lt; endl;\n    cout &lt;&lt; I-- &lt;&lt; endl;\n    cout &lt;&lt; --I &lt;&lt; endl;\n    cout &lt;&lt; *I  &lt;&lt; endl;\n}\n1.9.5 前闭后开 §\n[first,last)\n1.9.6 function call §\n伪函数\n#include&lt;iostream&gt;\n \nusing namespace std;\n \ntemplate&lt;class T&gt;\nstruct Plus {\n    T operator()(const T&amp; x, const T&amp; y) const {return x + y;}\n};\n \ntemplate&lt;class T&gt;\nstruct Minus {\n    T operator()(const T&amp; x, const T&amp; y) const {return x - y;}\n};\n \nint main() {\n    Plus&lt;int&gt; plusobj;\n    Minus&lt;int&gt; minusobj;\n \n    cout &lt;&lt; plusobj(3, 5) &lt;&lt;endl;\n    cout &lt;&lt; minusobj(3, 5) &lt;&lt;endl;\n \n    cout &lt;&lt; Plus&lt;int&gt;()(3, 5) &lt;&lt; endl;\n    cout &lt;&lt; Minus&lt;int&gt;()(3, 5) &lt;&lt; endl;\n}\n二、空间适配器(allocator) §\n四、序列式容器(sequence containers) §\n4.2 vector §\n4.2.2 vector定义摘要 §\ntemplate &lt;class T, class Alloc&gt;\nclass Vector {\npublic:\n    typedef T           value_type;\n    typedef value_type* pointer;\n    typedef value_type* iterator;\n    typedef value_type* reference;\n    typedef size_t      size_type;\n    typedef ptrdiff_t   difference_type;\n \nprotected:\n    typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;\n \n    iterator start;             // 目前使用的空间的头\n    iterator finish;            // 目前使用的空间的尾\n    iterator end_of_storage;    // 目前可用的空间的尾\n \n    void insert_aux(iterator position, const T&amp; x);\n    void deallocate() {\n        if (start)\n            data_allocator::deallocate(start, end_of_storage - start);\n    }\n    void fill_initialize(size_type n, const T&amp; value) {\n        start = allocate_and_fill(n, value);\n        finish = start + n;\n        end_of_storage = finish;\n    }\n \npublic:\n    iterator begin() {\n        return start;\n    }\n    iterator end()   {\n        return finish;\n    }\n    size_type size() const {\n        return size_type(end() - begin());\n    }\n    size_type capacity() const {\n        return size_type(end_of_storage - begin();)\n    }\n    bool empty() const {\n        return begin() == end();\n    }\n    reference operator[](size_type n) {\n        return *(begin() + n);\n    }\n \n    vector(): start(0), finish(0), end_of_storage(0) {}\n    vector(size_type n, const T&amp; value){\n        fill_initialize(n, value);\n    }\n    vector(int n, const T&amp; value) {\n        fill_initialize(n, value);\n    }\n    vector(long n, const T&amp; value) {\n        fill_initialize(n, value);\n    }\n    explicit vector(size_type n) {\n        fill_initialize(n, T());\n    }\n \n    ~vector() {\n        destroy(start, finish);\n        deallocate();\n    }\n \n    reference front() {\n        return *begin();\n    }\n    reference back() {\n        return *(end()-1);\n    }\n    void push_back(const T&amp; x) {\n        if(finish != end_of_storage) {\n            construct(finish, x);\n            ++finish;\n        }\n        else\n            insert_aux(end(), x);\n    }\n    void pop_back() {\n        --finish;\n        destroy(finish);\n    }\n    iterator erase(iterator position) {\n        if(position+1 != end())\n            copy(position+1, finish, position);\n        --finish;\n        destroy(finish);\n        return position;\n    }\n    void resize(size_type new_size, const T&amp; x) {\n        if(new_size &lt; size())\n            erase(begin()+new_size, end());\n        else\n            insert(end(), new_size-size(), x);\n    }\n    void resize(size_type new_size) {\n        resize(new_size, T());\n    }\n    void clear() {\n        erase(begin(), end());\n    }\n \nprotected:\n    iterator allocate_and_fill(size_type n, const T&amp; x) {\n        iterator result = data_allocator::allocate(n);\n        uninitialized_fill_n(result, n, x);\n        return result;\n    }\n};\n4.2.3 迭代器 §\nRandom Access Iterators\n4.2.4 数据结构 §\niterator start;             // 目前使用的空间的头\niterator finish;            // 目前使用的空间的尾\niterator end_of_storage;    // 目前可用的空间的尾\n4.2.5 构造与内存管理 §\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n \nusing namespace std;\n \nint main() {\n    vector&lt;int&gt; iv(2, 9);\n    cout &lt;&lt; iv.size()       &lt;&lt; endl; // 2\n    cout &lt;&lt; iv.capacity()   &lt;&lt; endl; // 2\n \n    iv.push_back(1);\n    cout &lt;&lt; iv.size()       &lt;&lt; endl; // 3\n    cout &lt;&lt; iv.capacity()   &lt;&lt; endl; // 4\n \n    iv.pop_back();\n    cout &lt;&lt; iv.size()       &lt;&lt; endl; // 2\n    cout &lt;&lt; iv.capacity()   &lt;&lt; endl; // 4\n \n    iv.clear();\n    cout &lt;&lt; iv.size()       &lt;&lt; endl; // 0\n    cout &lt;&lt; iv.capacity()   &lt;&lt; endl; // 4\n}\n动态增加大小: 以原大小的两倍另外配置一块较大的空间, 然后将原内容拷贝过来, 释放原空间, 导致原来指向vector的迭代器失效\n4.2.6元素操作 §\nvoid pop_back()\n \niterator erase(iterator first, iterator last)\n    \niterator erase(iterator position)\n    \nvoid clear()\n    \n// 从position开始, 插入n个元素, 值为x\nvoid insert(iterator position, size_type n, const T&amp; x)\n4.3 list §\n4.3.3 迭代器 §\nBidirectional Iterators\n插入(insert)和接合(splice)不会造成迭代器失效, erase只有**“指向被删除”**的迭代器失效\n4.3.4 list 的数据结构 §\n环状双向链表\n注意\n\n指针node指向尾部的空白节点，node就可以符合STL的前闭后开\nsize()方法复杂度是O(n)的\n\ntemplate&lt;class T&gt;\nclass list {\nprotected:\n    typedef __list_node&lt;T&gt; list_node;\npublic:\n    typedef list_node* link_type;\nprotected:\n    link_type node; // 用这个指针表示整个环状双向链表\n    \n    iterator begin() {return (link_type)((*node).next);}\n    iterator end()   {return node;}\n    bool empty() const {return node-&gt;next == node;}\n    \n    size_type size() const {\n        size_type result = 0;\n        distance(begin(), end(), result);\n        return result;\n    }\n    reference front() {return *begin();}\n    reference back() { return *(--end()); }\n    \n};\n4.3.6 list 的元素操作 §\n\npush_front:() insert(begin(), x);\npush_back(): insert(end(), x);\nerase(): return下一个节点的迭代器\npop_front(): erase(begin());\npop_back():\niterator tmp=end(); // 最后一个是空节点\nerase(—tmp);\nclear():\nwhile(cur != node) {…}\nnode-&gt;nxt = node, node-&gt;pre = node;\nremove(const T&amp; value); 将数值为value的所有元素移除\nunique(): 移除连续而相同的元素\ntransfer()\nsplice():\n\nx结合于position所指位置之前, x必须不同于*this\ni 所指元素接合于 position前\n将 [first, last) 所有元素结合与 position 前\n\n\nlist 不能使用STL的sort, 但是自带sort 成员函数\n因为STL的sort只接受RandomAccessIterator\n\n4.5 stack &amp; 4.6 queue §\ndeque 为底层的配接器(adapter), 没有迭代器"},"Y-存档/A-工程项目/面试/Vim":{"title":"Vim","links":[],"tags":["linux"],"content":"\n\n\n重复输入3次go 3igo&lt;Esc&gt;\n\n3: 声明次数\ni: 进入insert mode\ngo: 文本\n&lt;Esc&gt;: 退出insert mode\n\n\n寻找第4次出现的q 4fq\n跳转到与光标所在word的上/下一个\n\n*: 前\n#: 后\n\n\ns = x + i\n重复上一次的操作 .\ndk: 删除当前行和上一行\nD = d$\n==: 格式化当前行\n\n\ng;跳到上次edit的位置\ngi跳到上次insert的位置\n\n\n"},"Y-存档/A-工程项目/面试/面经":{"title":"春招记录","links":[],"tags":[],"content":"…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n时间公司简历笔试一面二面三面HR面03/02mihoyo✔❌bilibili❌斗鱼✔03/04阿里提前批❌03/10头条(运维)✔✔✔❌网易雷火(服务器)✔❌阿里提前批(飞天)✔❌03/16CVTE(c++)❌深信服(c++)✔❌腾讯(后台)✔✔❌03/19拼多多(服务器)美团(运维)✔✔❌Thoughtworks✔✔猿辅导(服务器)❌作业帮(运维)✔✔✔✔作业帮(C++)03/20快手(后台)❌华为(C++)❌百度(C++)✔✔✔❌西山居(服务器)七牛云(后端)360(C++)✔❌03/27阿里(C++)04/07腾讯(业务运维)✔❌\nMY OWN §\nA端: 开发界面\nB端: Business, 商家, 商业用户\nC端: Consumer, 消费者, 个人和家庭用户\n腾讯一面(3.22) §\n\n\nTEG: Technology and Engineering Group\n\n\n面向对象, 多态\n\n\n虚函数\n\n概念\n\n虚函数是为了允许用基类的指针来调用子类的这个函数\n纯虚函数是为了实现一个接口, 起到一个规范的作用\n\n\n对于虚函数来说, 父类和子类都有各自的版本。由多态方式调用的时候动态绑定\n虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。\n如果指针指向的是子类对象, 将调用子类的析构函数, 然后自动调用基类的析构函数\n意义\n\n为了安全, 因为避免任何需要明确但是因为不小心而导致的未知的结果, 提醒子类去做应做的实现\n为了编码的效率\n\n\n\n\n\n虚函数表\n\n\n快排, 堆排\n\n\n网络字节序, 大小端\n\n大端: 高位在前, 人类读写数值的方法\n小端: 低位在前\n\n除了计算机的内部处理, 其他的场合几乎都是大端字节序, 比如网络传输和文件储存\n“只有读取的时候，才必须区分字节序，其他情况都不用考虑。”\n历史原因是CPU架构不同, 为了规范所以让网络字节序为大端\n\n\n\n\n进程调度\n\n先来先服务, 短作业等待时间过长\n短作业优先, 长作业饿死\n最短剩余时间\n\n\n\n内存管理\n\n只读部分\n\n.text: 代码段\n.rodata: 常量\n\n\n读写部分\n\n.data: 初始化了全局变量, 静态变量\n.bss: 未初始化的全局变量, 静态变量\nheap: malloc, free\nstack: 函数调用, 生命周期被限制的变量\n\n\n页面置换算法\n\n先进先出\n先进先出·改\n最近最久未使用(LRU)\n时间片轮转\n\n\n\n\n\n阻塞, 非阻塞, 同步, 异步\n\n\n服务器容灾\n\n高可用: 两台机器, 备份机一直发hello包, 主机未应答的话, 主动接管业务\n冷备: 手动启动配置备份机\n容错: A运行时, 通过软件同步复制操作到B, A崩溃后, B立刻托管业务, 成本变高\n\n\n\n索引优化\n\n最左前缀匹配\na = 1 and b = 2 and c &gt; 3 and d = 4, (a, b, c, d)索引用不到d\ncount(distinct col) / count(*) 越大越好, 最大是唯一键的1\n索引列不参与计算\n拓展索引, 不要新建索引\n\n\n\nlimit优化\n\n\nlimit的逻辑\nselect * from table_name limit 10000,10\n\n从数据表中读取第N条数据添加到数据集中\n重复第一步直到 N = 10000 + 10\n根据 offset 抛弃前面 10000 条数\n返回剩余的 10 条数据\n\n\n\n自增索引\n\n\n先把索引列查找出来\n\n\ninner join\n\n\n\n\n腾讯二面 §\n\n\n进程通信\n\n共享内存: 不需要系统调用, 所以效率最高, 但是没有同步互斥机制\n\n\n\n范式\n\n第一范式: 每个属性不可再分\n第二范式: 消除了非主属性对于码的部分函数依赖\n实体的属性完全依赖于主关键字，即：不能存在仅依赖主关键字的一部分\n(学号, 课程号, 得分, 课程名)\n第三范式: 消除数据库中关键字之间的依赖关系\n消除传递依赖\n(学号, 系别, 系主任)\nBCNF范式: 不允许主键的一部分被另一部分或其它部分决定\n(学生, 老师, 课程)\n\n\n\nuuid不重复的原理\n\n时间戳\n名字的MD5散列\n\n\n\n腾讯(业务运维)一面 §\n\nmysql修改字段名\nmysql修改字段值\n查看IO\niostat\n修改DNS服务器ip\n\n非永久解决方案: /etc/resolv.conf\n永久解决方案: /etc/dhcp/dhclient.conf\n\n\n\n腾讯(业务运维)二面 §\n\n\nTCP端口一共多少个\n16位, 216=65536, 所以是0-65535\n\n\n端口分类\n\n公认端口: 0-1023\n注册端口: 松散的绑定一些服务\n动态和私有端口: 49152-65535, 可用于任意软件与任何其他的软件通信的端口数，使用因特网的传输控制协议，或用户传输协议。\n\n\n\n文件权限:\n拥有者, 拥有者所在用户组, 其他用户\n\n\n如何判断tcp超时\n\n3次ACK快重传\nα·SRTT +（1 - α）·RTT\n容易混淆的知识\n\nMSL: maximum segment lifetime, 最大报文生存时间\nTTL: time to live, 路由的跳数\nRTT: round trip time, 往返时延, 数据包回环一圈的时间\nRTO: Retransmission Time Out, 重传超时\n\n\n\n\n\ntcp 可靠性\n\n校验和\n字节编号\n数据段确认\n\n一次发送滑动窗口大小个数据段\n对连续接受的数据段的最后一个序号进行确认\n不连续的已经接受的缓存\n超时重传\n\n\n\n\n\n如何创建进程\n\nfork(): 复制当前进程, 返回父进程和子进程ID一共两次\nvfork(): 产生子进程和父进程共享地址空间\nclone(): clone可以让你有选择性的继承父进程的资源\n\n\n\n\nmysql服务的连接过程\n\n\n\n腾讯(业务运维)三面 §\n\n\nbash是如何执行命令的\n\n\n执行交互式命令\n\nfork当前进程并且exec执行命令\n内建命令不创建新进程cd, alias, export\n\n\n\n执行脚本\n\n\n./script.sh(需要可执行权限): fork成子进程, exec系统调用\n\n用script.sh程序代码替换子进程代码\n从_start开始执行\n\n\n\n/bin/sh ./script.sh(不需要可执行权限)\n\n用解释器程序代码替换子进程代码\n从 解释器的_start开始执行\n\n\n\n实例\n#!/bin/sh\ncd ..\nls\n\n交互Shell（bash）fork/exec一个子Shell（sh）用于执行脚本，父进程bash等待子进程sh终止\nsh读取脚本中的cd ..命令，调用相应的函数执行内建命令，改变当前工作目录为上一级目录\nsh读取脚本中的ls命令，fork/exec这个程序，列出当前工作目录下的文件，sh等待ls终止\nls终止后，sh继续执行，读到脚本文件末尾，sh终止\nsh终止后，bash继续执行，打印提示符等待用户输入\n\n\n\n\n\n\n\n\nfork底层\n\n\n查看某个进程的系统调用\nstrace -p pid\n\n\n用户态和内核态是如何切换的\n\n\n分配给进程的资源包括什么, 又是如何分配的\n\n\n进程调度算法\n\n先来先服务\n短作业优先\n最高响应比(响应比 = 1+作业等待时间/作业处理时间)\n优先级调度\n\n\n\n时间片轮转算法\n5ms - 800ms\n\n\n深信服(C++)一面 §\n\n\n为什么会有hash冲突\n根据输入值变成固定的长度，必然存在不同的输入产生相同的值\n\n\ntime33算法\npublic int time33(char[] str) {\n    int hash = 0;\n    for (char c : str) {\n        hash = hash * 33 + c;\n    }\n    return hash;\n}\n\n\n百度(C++)一面 §\n\ntcp建立连接为什么需要三次\n\n为什么不需要四次(ii, iii可以合并)\n\nA —syn+seq(A)=x—&gt; B\nB ----ack=x+1--- —&gt; A\nB —syn+seq(B)=y—&gt; A\nA ----ack=y+1------&gt; B\n\n\n为什么不能是两次(不能就B的初始序列号达成一致)\n\nA —syn+seq(A)=x—&gt; B\nB —syn+seq(B)=y+ack=x+1—&gt; A\n\n\n\n\ntcp断开连接为什么需要四次\n\n第二次挥手完成的时候，服务端可能还有数据要发送\n所以只能先发送ack确认\n\n\n内存排布\n进程资源是如何隔离的\n\nnamespace是Linux提供的资源隔离机制。只有在同一个namespace下的进程可以相互联系，但无法感受到外部进程的存在，营造出处于一个独立的系统环境中的错觉，从而实现了隔离。\ncgroup提供\n\n资源限制\n优先级控制\n资源统计\n任务控制\n\n\n\n\n死锁的条件\n\n互斥: 一个资源只能被一个进程占用\n请求和保持等待: 一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持占有\n不可抢占\n循环等待: 所等待的进程必定会形成一个环路\n\n\n死锁的预防\n\n打破互斥: 实际意义不大\n打破请求和保持等待: 一次性申请需要的全部资源\n\n进程是动态的，不可能提前预知资源多少\n资源利用率低，降低了资源使用的并发性\n\n\n打破不可抢占: 允许分配已占有的资源\n打破循环等待：资源有序分配\n\n\n死锁的避免\n\n银行家算法\n\n\n死锁的检测\n\n发生死锁时，最小代价恢复运行\n发现环路说明有死锁\n\n\n死锁的恢复\n\n按照进程优先级撤销进程\n\n\n\n百度二面 §\n\n\nGC\n\n引用计数法\nmark sweep\n维护不需要GC的\n\n\n\n线程安全的单例模式\n\n\n饿汉版\n#include &lt;bits/stdc++.h&gt;\n \nusing namespace std;\n \nclass single {\nprivate:\n    single() = default;\n \n    ~single() = default;\n \n    static single *instance;\npublic:\n    int val = 2;\n \n    static single *getInstance() {\n        return instance;\n    }\n};\n \nsingle *single::instance = new single();\n \nint main() {\n    cout &lt;&lt; single::getInstance()-&gt;val &lt;&lt; endl;\n}\n \n\n\n懒汉版\n#include &lt;bits/stdc++.h&gt;\n \nusing namespace std;\n \nclass single {\nprivate:\n    single() = default;\n \n    ~single() = default;\n \n    static single *instance;\n \n    static mutex _mutex;\npublic:\n    int val = 2;\n \n    static single *getInstance() {\n        if (instance == nullptr) {\n            unique_lock&lt;mutex&gt; lock(_mutex);\n            if (instance == nullptr)\n                instance = new single();\n        }\n        return instance;\n    }\n};\n \nsingle *single::instance = nullptr;\nmutex single::_mutex;\n \n \nint main() {\n    cout &lt;&lt; single::getInstance()-&gt;val &lt;&lt; endl;\n}\n \n\n\n\n\n作业帮(运维)一面 §\n\n软硬链接区别\n\n硬连接共享inode\n若原来的文件删除了，软链接不可访问，硬链接可以访问\n软链接可以跨磁盘，硬连接不行\n\n\n如何在log文件打开的情况下删除\n运维的工作\n\n对全平台的业务的监控与部署\n服务部署的效率化与自动化\n降低运维的成本\n一整套服务的生命周期的管理\n\n\n\n作业帮(运维)二面 §\n\n\n常见http请求头\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n请求头说明Accept文件类型(text/css)Accept-Encoding压缩方式(gzip)Accept-Languagezh, cnUser-Agent操作系统，浏览器method\n\n\n常见http响应头\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n响应头说明Content-Type文件类型(text/css)Content-Encoding压缩方式(gzip)Content-Languagestatus状态码(200)method\n\n\n301与302, 常见状态码\n\n301: 永久重定向(http://www.baidu.com跳转https://www.baidu.com)\n302: 临时跳转(未登陆的用户访问用户中心重定向到登录页面)\n400: 客户端请求有语法错误\n403: 服务端收到请求, 但是拒绝提供服务\n404: 请求的资源不存在\n\n\n\ncookie 和 session区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncookiesession存取方式ASCII字符串任意类型隐私策略客户端可见存储在服务器有效期时间可以设置比较长不可能又多又长跨域支持不支持\n\n\nwebsocket\n\n基于TCP的真正的全双工通信，客户端和服务器都可以正常接受与发送数据\n建立TCP连接后，不需要HTTP header\n通信协议符为(ws, wss)\n\n\n\n事务是什么\n满足ACID的一组操作\n\n\n为什么需要事务\n保证数据库中数据的完整性和正确性\n\n\n字节(运维)二面 §\n\n聚簇索引\n聚簇索引的数据的物理存放顺序与索引顺序是一致，IO时间变少\n\n暑期实习面经 §\n阿里一面 §\n\n\nconst\n\n\nconst修饰普通变量: 常量不能修改(注意编译器优化, volatile)\n\n\nconst修饰指针变量\n\n\n修饰指针指向的内容: 内容不可变\nconst int *p = 8;\n\n\n修饰指针: 指针不可变\nint* const p = &amp;a;\n*p = 9; // 正确\np = &amp;b; // 错误\n\n\n修饰指针和指针指向的内容: 均不可变\n\n\n\n\nconst参数传递\n\n\n按值传递的参数: 可以当没有必要(本来就是拷贝)\n\n\n指针参数\nvoid Cpf(int *const a)\n{\n    cout&lt;&lt;*a&lt;&lt;&quot; &quot;;\n    *a = 9;\n}\n\n\n自定义类型的参数\n\n\n\n\nconst函数返回值\n\n\nconst修饰内置类型: 是否修饰作用一样\nconst int Cmf()\n{\n    return 1;\n}\n\n\nconst修饰函数指针\nconst char *getStr() {\n    return &quot;dddd&quot;;\n}\n \nconst char *str = getStr();\n\n\n\n\nconst修饰成员函数\nconst 修饰类成员函数，其目的是防止成员函数修改被调用对象的值\nclass {\n    int get_cm()const\n    {\n       return _cm;\n    }\n}\n\n\n\n\n多态\n一个接口, 多种行为\n\n编译时多态: 函数重载与模板(静态)\n运行时多态: 虚函数(动态)\n\n析构函数: 在多态基类中使用虚析构函数\n\n\n指针和引用\n\n\n代码\nint a=1;int *p=&amp;a; // p是指针\nint a=1;int &amp;b=a;  // b是引用, 和a相同\n\n\n可以有const指针，但是没有const引用\n\n\n指针可以有多级，但是引用只能是一级\n\n\n指针可以改变，但引用不可改变\n\n\n“sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小\nint b=&amp;a;\nsizeof(b); // 4\nsizeof(int *); // 8(64位)\n\n\n函数参数\n\n\n指针本质还是值传递\n\n\n引用传递的是实参本身\nvoid test(int &amp;a)\n{\n　　cout&lt;&lt;&amp;a&lt;&lt;endl;\n}\n \nint main(void)\n{\n    int a=1;\n    cout&lt;&lt;&amp;a&lt;&lt;endl;\n    test(a);\n    return 0;\n}\n \n// 0x7ffdf0564b14\n// 0x7ffdf0564b14\n\n\n\n\n\n\n判断链表是否循环\nleetcode141\n\n\nCVTE C++ §\n一面 §\n\n\nRTSP协议\nRTSP(Real-TimeStream Protocol )被用于建立的控制媒体流的传输，它为多媒体服务扮演“网络远程控制”的角色。尽管有时可以把RTSP控制信息和媒体数据流交织在一起传送，但一般情况RTSP本身并不用于转送媒体流数据。媒体数据的传送可通过RTP/RTCP等协议来完成。\n实时传输控制协议(Real-time ControlProtocol，RTCP)与RTP共同定义在1996年提出的RFC 1889中，是和 RTP一起工作的控制协议。RTCP单独运行在低层协议上，由低层协议提供数据与控制包的复用。\n\n\n基于UDP和TCP的传输有什么区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTCPUDP无状态面向连接无连接面向报文字节流模式数据报模式只能一对一可以多对多系统资源消耗大****小保证数据正确可能丢包保证数据顺序可能丢包流量控制,拥塞控制,超时重传,校验和尽力交付\n\n\n如何解决UDP传输乱序的问题?\ntcp的seq\n\n\nshared_ptr和unique_ptr有什么区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nshared_ptrunique_ptr计数器独有make_shared只能new\n\n\nshared_ptr如何做到多个同时管理一个对象\n计数器, use_count, unique\n\n\nunique_ptr可以拷贝吗?为什么不能拷贝?\n拷贝构造函数是被删除的\n\n\nc++多态如何理解?\n一个接口, 多种行为\n\n编译时多态: 函数重载与模板(静态)\n运行时多态: 虚函数(动态)\n\n\n\n多进程和多线程的区别\n线程是CPU调度的基本单元\n进程是系统资源分配的基本单元\n\n\n如何在两个进程间共享一个对象\n\n共享内存\n管道\nMQ\n\n\n\n虚拟地址空间\n\n部分映射物理内存\n伪连续, 不需要物理内存连续\n\n\n\n电话面 二面 §\n\nmmap原理\nmmap将一个文件或者其它对象映射进内存, 文件被映射到多个页上\n\n在用户虚拟地址空间中寻找空闲的满足要求的一段连续的虚拟地址空间,为映射做准备(由内核mmap系统调用完成)\n建立虚拟地址空间和文件或设备的物理地址之间的映射(设备驱动完成)\n缺页中断\n\n\n直接写磁盘的性能损耗\n操作系统和C库函数通常会对写入的文件内容做缓存，以减少实际写文件的次数。直接调用系统函数fsync或C函数fflush将使系统的缓存机制失效，此时将强制把内容刷到磁盘上。除非必需，否则不要执行强制刷盘操作。\n\n腾讯暑期实习面试 §\n一面 §\n\n\n进程线程通信\n\n进程: 管道, 有名管道, 信号量, 消息队列, 共享内存, 套接字\n线程: 锁, 信号量\n\n\n\nMySQL索引\nMySQL 5.5以前的默认存储引擎是MyISAM, MySQL 5.5之后的默认存储引擎是InnoDB\n\nMyISAM\n\n没有事务\n全文索引(like %XXX)\n表级锁\n表压缩(io密集)\ncount()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性说明InnoDBMyISAMMEMORYB树索引 (B-tree indexes)自增ID物理连续性更高， 二叉树，红黑树高度不可控√√√R树索引 (R-tree indexes)空间索引√哈希索引 (Hash indexes)无法做范围查询√√全文索引 (Full-text indexes)√√\n\nB树是多路树，红黑树是二叉树！红黑树一个节点只能存出一个值，B树一个节点可以存储多个值，红黑树的深度会更大,定位时 红黑树的查找次数会大一些。\n高度\n局部性原理\n\n\n\nMySQL的联合索引\n叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且按照col1、col2、col3的顺序进行排序\n\n\nhttps是什么\n\nhttp的安全版本\nssl(Transport Layer Security) -&gt; tls(Transport Layer Security)\n\n\n\nhttps 过程\n\nTCP三次握手(1.5-RTT)\n\n\n\nTLS四次握手(2-RTT)\n\n\nHTTP交互 (1-RTT), 真正传输数据的\n\n\n\n\n服务端的状态码\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n状态码2XX成功3XX重定向4XX客户端错误5XX服务端错误\n\n\n加密算法有哪些\n\n对称加密: DES, 3DES, AES\n非对称加密: RSA, DSA\nSHA-1, MD5\n\n\n\nCA证书\n\nA服务器产生公钥私钥后向root ca发送请求\nroot ca发送用自己的私钥加密的A服务器的证书\n浏览器一般带有权威认证机构的公钥\n这个公钥可以用来解密证书证明自己是自己\n\n\n\nrestful接口\n\nAPI与用户的通信协议，总是使用HTTPs协议\n每个网址代表一种资源(resource)\n动词\n\n\n\nget和post区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGETPOST一般是获取一般是发送数据url可见&lt;=2kb一般无限制安全性低, 无加密\n\n\nhttp1.0, 1.1, 2.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP1.0新增了POST, 一次请求一次连接1.1keep-alive, 管道, 分块2.0二进制, 多路复用, 主动推送, 头部压缩\n\n\nTCP怎么可靠传输\n拥塞控制, 流量控制, 校验和, 超时重传, 字节编号\n\n\n滑动窗口是什么\n接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小\n\n\n拥塞窗口\n拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口\n\n\n二面 §\n\n\n浏览器输入一个网址，发生的事情\n\n\ncdn是什么\n大号的缓存代理\n\n\n"},"Y-存档/A-工程项目/项目/alicevision":{"title":"alicevision","links":[],"tags":[],"content":"\n\n编译 §\n环境：Ubuntu20.04\n版本\n\n\n如果系统中预先有一些旧依赖。首先会碰到 cmake 的 include 目录正确，但是 lib 寻找目录错误的问题。详见这个 issue。根据这篇文章，通过设置 CMake 搜索的优先级，可以解决路径查询问题。解决方案。\n\n\n编译 aliceVision，为了省时，可以将项目分为两部分编译。\n\n\n使用 CMakeLists 里面的内置方法对依赖进行编译。\n\n\n在 CMakeLists 中关闭依赖编译后，再对项目进行单独编译。\n\n\n\n\nUbuntu20.04 默认版本为 3.16 尝试使用代理失败。但是换成官网源码编译的 3.22 后代理能正常工作了。\n\n\n不确定问题：将 CMAKE_PREFIX_PATH 设置成依赖安装目录后，CMake 会出现以下 warning:\nCMake Warning (dev) in src/CMakeLists.txt:\nPolicy CMP0111 is not set: An imported target missing its location property\nfails during generation.  Run &quot;cmake --help-policy CMP0111&quot; for policy\ndetails.  Use the cmake_policy command to set the policy and suppress this\nwarning.\n\nIMPORTED_LOCATION not set for imported target &quot;assimp::assimp&quot;\nconfiguration &quot;Debug&quot;.\n\n进而导致 make 的规则中找不到 assimp 的依赖。\nLinux-x86_64/libaliceVision_mesh.so.2.4: assimp::assimp-NOTFOUND\n\n\n解决办法：按照 warning 提示添加 IMPORTED_LOCATION\n# /home/chunibyo/workspace/AliceVision/src/aliceVision/mesh/CMakeLists.txt\nset_target_properties(assimp::assimp PROPERTIES IMPORTED_LOCATION &quot;${ASSIMP_LIBRARY_DIRS}/${ASSIMP_LIBRARIES}&quot;)\n\n\n\n调试 §\naliceVision 分为前端和后端两个部分。\n后端编译得到一系列可执行二进制文件，可以通过命令行调用，默认生成在 /home/chunibyo/workspace/AliceVision/build/Linux-x86_64 路径下。\n前端通过 subprocess.Popen 对后端的二进制文件进行调用。\n因为对 c++ 的调用方式子进程，所以很难直接 gdb 进 python 进程后对 c++ 进行 debug。解决办法是设法使后端的进程停住，然后在 CLion 中直接 attach 进去。\n\n\naliceVision_cameraInit §\n处理照片的元信息。\n命令：\naliceVision_cameraInit  --sensorDatabase &quot;/home/chunibyo/workspace/AliceVision/src/aliceVision/sensorDB/cameraSensors.db&quot; --defaultFieldOfView 45.0 --groupCameraFallback folder --allowedCameraModels pinhole,radial1,radial3,brown,fisheye4,fisheye1,3deanamorphic4,3deradial4,3declassicld --useInternalWhiteBalance True --viewIdMethod metadata --verboseLevel info --output &quot;/home/chunibyo/workspace/meshroom_cache/tmp/MeshroomCache/CameraInit/db58d443c068acdfe5245d3670f4ba016ff52160/cameraInit.sfm&quot; --allowSingleView 1 --input &quot;/home/chunibyo/workspace/meshroom_cache/tmp/MeshroomCache/CameraInit/db58d443c068acdfe5245d3670f4ba016ff52160/viewpoints.sfm&quot;\n参数：\n\n\nsensorDatabase：拍摄设备的先验硬件信息 txt 数据库。\n\n\ngroupCameraFallback：\n\n\nglobal\n\n\nfolder\n\n\nimage\n\n\n\n\nrig：https://github.com/alicevision/meshroom/wiki/Multi-Camera-Rig\n同时支持输入初始位姿。\naliceVision_featureExtraction §\n主要计算代码\nThe SIFT detector is controlled mainly by two parameters: the peak threshold and the (non) edge threshold.\nThe peak threshold filters peaks of the DoG scale space that are too small (in absolute value). Peak_thresh 越大，特征点越少。\n\nThe edge threshold eliminates peaks of the DoG scale space whose curvature is too small (such peaks yield badly localized frames). edge_thresh 越大，特征越多。\n\n\n可选特征点\n\nstd::string EImageDescriberType_informations()\n{\n  return  &quot;Describer types used to describe an image:\\n&quot;\n          &quot;* sift: Scale-invariant feature transform.\\n&quot;\n          &quot;* sift_float: SIFT stored as float.\\n&quot;\n          &quot;* sift_upright: SIFT with upright feature.\\n&quot;\n          &quot;* akaze: A-KAZE with floating point descriptors.\\n&quot;\n          &quot;* akaze_liop: A-KAZE with Local Intensity Order Pattern descriptors.\\n&quot;\n          &quot;* akaze_mldb: A-KAZE with Modified-Local Difference Binary descriptors.\\n&quot;\n#if ALICEVISION_IS_DEFINED(ALICEVISION_HAVE_CCTAG)\n          &quot;* cctag3: Concentric circles markers with 3 crowns.\\n&quot;\n          &quot;* cctag4: Concentric circles markers with 4 crowns.\\n&quot;\n#endif\n#if ALICEVISION_IS_DEFINED(ALICEVISION_HAVE_APRILTAG)\n          &quot;* tag16h5: AprilTag family tag16h5.\\n&quot;\n#endif\n#if ALICEVISION_IS_DEFINED(ALICEVISION_HAVE_OPENCV)\n#if ALICEVISION_IS_DEFINED(ALICEVISION_HAVE_OCVSIFT)\n          &quot;* sift_ocv: OpenCV implementation of SIFT describer.\\n&quot;\n#endif\n          &quot;* akaze_ocv: OpenCV implementation of A-KAZE describer.\\n&quot;\n#endif\n          &quot;&quot;;\n}\n\nConfigurationPreset: 特征点预设，默认 NORMAL\n\n/**\n* @brief The preset to control the number of detected regions\n*/\nenum class EImageDescriberPreset\n{\n  LOW = 0\n  , MEDIUM\n  , NORMAL\n  , HIGH\n  , ULTRA\n};\n\n\nmaxNbFeatures：手动设置特征点数目的方法\n\n\ndescriberQuality: 手动设置特征点的质量。提高质量后会增加scale层数。It’s a trade-off between performance and precision.\n\n\ncontrastFiltering: 默认是 static，根据某种标准对关键点进行权重排序\n\n\n    /**\n    * @brief The method used to filter out features with too low constrast (that can be considered as noise).\n    */\n    enum class EFeatureConstrastFiltering\n    {\n        /// Use a fixed threshold for all the pixels\n        Static = 0,\n        /// Use a threshold for each image based on image statistics\n        AdaptiveToMedianVariance,\n        /// Disable contrast filtering\n        NoFiltering,\n        /// Grid sort by peak value per octave and by scale at the end\n        GridSortOctaves,\n        /// Grid sort by scale*peakValue per octave and at the end\n        GridSort,\n        /// Grid sort per scale steps and at the end (scale and then peak value)\n        GridSortScaleSteps,\n        /// Grid sort per octaves and at the end (scale and then peak value)\n        GridSortOctaveSteps,\n        /// Filter non-extrema peak values\n        NonExtremaFiltering\n    };\n\n\nrelativePeakThreshold: dynPeakTreshold = relativePeakThreshold * medianOfGradiants\n\n\ngridFiltering: 指的是尽量不使得某个格子内的特征点过于密集。首先会根据 scale 或者 peak 等进行排序。分为留下的和舍弃两部分特征点。\n\n"},"Y-存档/A-工程项目/项目/deepin-screen-recorder":{"title":"deepin screen recorder","links":["\"https:/gist.github.com/chunibyo-wly/d8d8c2c550640b471f5939bf6f76e752.js\""],"tags":["qt"],"content":"\n\nqt vscode debug 配置\n这个项目由两个进程组成，之间通过 dbus 进行沟通。\n{\n\t&quot;version&quot;: &quot;2.0.0&quot;,\n\t&quot;tasks&quot;: [\n\t\t{\n\t\t\t&quot;type&quot;: &quot;shell&quot;,\n\t\t\t&quot;label&quot;: &quot;qmake build makefile&quot;,\n\t\t\t&quot;command&quot;: &quot;/usr/bin/qmake&quot;,\n\t\t\t&quot;args&quot;: [\n\t\t\t\t&quot;..&quot;\n\t\t\t],\n\t\t\t&quot;options&quot;: {\n\t\t\t\t&quot;cwd&quot;: &quot;${workspaceFolder}/build&quot;\n\t\t\t},\n\t\t\t&quot;problemMatcher&quot;: [],\n\t\t\t&quot;group&quot;: &quot;build&quot;,\n\t\t},\n\t\t{\n\t\t\t&quot;type&quot;: &quot;shell&quot;,\n\t\t\t&quot;label&quot;: &quot;make build activefile&quot;,\n\t\t\t&quot;command&quot;: &quot;/usr/bin/make&quot;,\n\t\t\t&quot;args&quot;: [\n\t\t\t\t&quot;${nproc}&quot;\n\t\t\t],\n\t\t\t&quot;options&quot;: {\n\t\t\t\t&quot;cwd&quot;: &quot;${workspaceFolder}/build&quot;\n\t\t\t},\n\t\t\t&quot;problemMatcher&quot;: [],\n\t\t\t&quot;group&quot;: &quot;build&quot;,\n\t\t\t&quot;dependsOn&quot;: [\n\t\t\t\t&quot;qmake build makefile&quot;\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t&quot;type&quot;: &quot;shell&quot;,\n\t\t\t&quot;label&quot;: &quot;launch deepin screen recorder&quot;,\n\t\t\t&quot;command&quot;: &quot;./build/src/deepin-screen-recorder&quot;,\n\t\t\t&quot;args&quot;: [],\n\t\t\t&quot;options&quot;: {\n\t\t\t\t&quot;cwd&quot;: &quot;${workspaceFolder}&quot;\n\t\t\t},\n\t\t\t&quot;problemMatcher&quot;: [],\n\t\t\t&quot;group&quot;: &quot;build&quot;,\n\t\t\t&quot;dependsOn&quot;: []\n\t\t}\n\t]\n}\n{\n    &quot;version&quot;: &quot;0.2.0&quot;,\n    &quot;configurations&quot;: [\n        {\n            &quot;name&quot;: &quot;deepin-pin-screenshots&quot;,\n            &quot;type&quot;: &quot;cppdbg&quot;,\n            &quot;request&quot;: &quot;launch&quot;,\n            &quot;program&quot;: &quot;${workspaceFolder}/build/src/pin_screenshots/deepin-pin-screenshots&quot;,\n            &quot;args&quot;: [&quot;--dbus&quot;],\n            &quot;stopAtEntry&quot;: false,\n            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,\n            &quot;environment&quot;: [],\n            &quot;externalConsole&quot;: false,\n            &quot;MIMode&quot;: &quot;gdb&quot;,\n            &quot;setupCommands&quot;: [\n                {\n                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,\n                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,\n                    &quot;ignoreFailures&quot;: true\n                }\n            ],\n            &quot;preLaunchTask&quot;: &quot;make build activefile&quot;,\n            &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;,\n            &quot;visualizerFile&quot;: &quot;${workspaceFolder}/.vscode/qt.natvis&quot;,\n            &quot;showDisplayString&quot;: true,\n        }\n    ]\n}"},"Y-存档/A-工程项目/项目/mmcv-CUDA-单元测试":{"title":"mmcv CUDA 单元测试","links":[],"tags":["CUDA"],"content":"\n\nmmcv 提供中使用 CUDA 算子作为 Pytorch 扩展。\n并且提供了 Python 层的对 CUDA Kernel 的单元测试。\n为了对更小的函数进行单元测试，尝试将 CUDA 文件单独从仓库中分离出来。\n参考这个仓库。\n但是 cuda 代码中使用了 Pytorch C++ 依赖。\nmmcv 中使用的是 setuptools 进行的编译，但是使用 cmake 一直没有配置成功。\n于是使用 libtorch 进行依赖代替。\nproject(cuda_gtest_plugin_examples)\ncmake_minimum_required(VERSION 2.8)\n\nset(CMAKE_PREFIX_PATH $ENV{LIBTORCH_PATH})\n\nset( CUDA_ARCH &quot;sm_86&quot; CACHE STRING &quot;CUDA architecture to compile for&quot; )\nset( GTEST_HOME $ENV{GTEST_HOME} CACHE FILEPATH &quot;Path to gtest root directory (assumes libgtest.a is placed in $GTEST_HOME/build)&quot; )\n\nSET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -pthread&quot;)\n\ninclude_directories( ${GTEST_HOME}/googletest/include )\nlink_directories( ${GTEST_HOME}/build/lib )\n\nfind_package(PythonInterp REQUIRED)\nfind_package(CUDA REQUIRED)\nfind_package(Torch REQUIRED)\n\nset( CUDA_NVCC_FLAGS &quot;${CUDA_NVCC_FLAGS} -arch=${CUDA_ARCH} \n                        -D__CUDA_NO_HALF_OPERATORS__ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ \n                        -D_GLIBCXX_USE_CXX11_ABI=1 -lpthread&quot; )\n \ncuda_add_executable(example_cuda_gtest main.cc src/example_test.cu)\ntarget_link_libraries(example_cuda_gtest pthread)\ntarget_link_libraries(example_cuda_gtest libgtest.a ${TORCH_LIBRARIES})\n\ncuda_add_executable(convex_gtest main.cc src/convex_test.cu)\ntarget_link_libraries(convex_gtest pthread)\ntarget_link_libraries(convex_gtest libgtest.a ${TORCH_LIBRARIES})\n发现使用 vscode 的 cmake-tools 插件可以进行 debug。看命令好像使用的是 gdb。\n"},"Y-存档/A-工程项目/项目/remark":{"title":"remark","links":[],"tags":["remarkjs"],"content":"\n\nremark-parse §\nremark-parse使用了mdast对markdown进行语法解析成为这些节点。\n使用unist-util-visit可以对生成的抽象语法树进行遍历，并且根据所需要的标签选择节点。\nprobot §\nprobot是一个GitHub App 框架。可以直接通过cli脚手架创建一个这样项目。\n\nGitHub webhook event"},"Y-存档/A-工程项目/项目/设计模式":{"title":"设计模式","links":[],"tags":["cpp"],"content":"\n\n图说设计模式\n创建型(Design Pattern) §\n1. 简单工厂(Simple Factory) §\n\n\n一个Factory根据传入的参数不同生产各种实例Product\n\nJava获取不同加密算法的密钥生成器\nKeyGenerator keyGen=KeyGenerator.getInstance(&quot;DESede&quot;);\n2. 工厂方法(Factory Method) §\n\n\n一个Factory有一个对应的Product\n\nJDBC\nConnection conn=DriverManager.getConnection(&quot;jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=&quot;);\nStatement statement=conn.createStatement();\nResultSet rs=statement.executeQuery(&quot;select * from UserInfo&quot;);\n3. 抽象工厂(Abstract Factory) §\n\n4. 建造者模式(Builder) §\nBuilder作为抽象父类, 定义了ABC等若干的build方法\n在ConcreteBuilder中实例Product, 并且实现Builder中的build方法, 留一个return Product的对外方法\n由Director选取哪一种ConcreteBuilder进行build\n\n5. 单例模式(Singleton) §\n保证一个类只有一个实例, 并且提供一个访问该实例的全局访问点\n\n任务管理器\n回收站\n配置文件读取\n\n\n构造函数私有\n靠一个get的static方法return出去一个static的成员\n\n//\n// Created by chunibyo on 2/27/20.\n//\n \n#ifndef INC_05_SINGLETON_SINGLETON_H\n#define INC_05_SINGLETON_SINGLETON_H\n \nclass Singleton {\n \nprotected:\n    static Singleton *singleton;\n \n    Singleton() = default;\n \n    ~Singleton() {\n        delete singleton;\n    }\n \npublic:\n    static Singleton *getInstance() {\n        if (singleton == nullptr) {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n \n};\n \nSingleton *Singleton::singleton = nullptr;\n \n#endif //INC_05_SINGLETON_SINGLETON_H\n结构型(Structural Pattern) §\n1. 适配器模式(Adapter) §\n把需要与外界交互那个接口继承下来, 再在继承下来的Adapter里面声明多个Adaptee进行交互\n比如说想要调用XXuse()方法, 但是只有use()方法, 就可以在子类里面调用了\n注意: C++父类使用子类方法是在父类的virtual方法情况下, 与Java不同\n// Adapter.cpp\n \nvoid Adapter::use() {\n    adaptee-&gt;specific_use();\n}\n \nAdapter::Adapter(Adaptee *adptee) {\n    this-&gt;adaptee = adptee;\n}\n3. 装饰器模式(Decorator) §\n\n#include &lt;iostream&gt;\n \nusing std::cout;\nusing std::endl;\n \nclass Component {\npublic:\n    virtual void operation() = 0;\n};\n \nclass ConcreteComponent : public Component {\npublic:\n    void operation() override {\n        cout &lt;&lt; &quot;拍照&quot; &lt;&lt; endl;\n    }\n};\n \nclass Decorator : public Component {\npublic:\n    Component *component;\n \n    explicit Decorator(Component *_component) {\n        component = _component;\n    }\n \n};\n \nclass ConcreteDecorator : public Decorator {\npublic:\n    explicit ConcreteDecorator(Component *_component) : Decorator(_component) {\n \n    }\n \n    void operation() override {\n        cout &lt;&lt; &quot;美颜&quot; &lt;&lt; endl;\n        component-&gt;operation();\n    }\n \n};\n \nint main() {\n    (new ConcreteComponent())-&gt;operation();\n    cout &lt;&lt; endl;\n    (new ConcreteDecorator(new ConcreteComponent()))-&gt;operation();\n}\n\n4. 外观模式(Facade) §\n\n#include &lt;iostream&gt;\n \nusing std::cout;\nusing std::endl;\n \nclass system {\npublic:\n    virtual void operation() = 0;\n};\n \nclass systemA : public system {\npublic:\n    void operation() override {\n        cout &lt;&lt; &#039;A&#039; &lt;&lt; endl;\n    }\n};\n \nclass systemB : public system {\npublic:\n    void operation() override {\n        cout &lt;&lt; &#039;B&#039; &lt;&lt; endl;\n    }\n};\n \nclass systemC : public system {\npublic:\n    void operation() override {\n        cout &lt;&lt; &#039;C&#039; &lt;&lt; endl;\n    }\n};\n \nclass Facade {\n    systemA *system_a;\n    systemB *system_b;\n    systemC *system_c;\npublic:\n    explicit Facade() {\n        system_a = new systemA();\n        system_b = new systemB();\n        system_c = new systemC();\n    }\n \n    void operation() {\n        system_a-&gt;operation();\n        system_b-&gt;operation();\n        system_c-&gt;operation();\n    }\n \n    virtual ~Facade() {\n        delete system_a;\n        delete system_b;\n        delete system_c;\n    }\n};\n \nint main() {\n    (new Facade())-&gt;operation();\n}\n5. 享元模式(Flyweight) §\n创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象。\n享元模式的目的就是使用共享技术来实现大量细粒度对象的复用。\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n \nusing std::cout;\nusing std::endl;\nusing std::string;\n \nclass Tree {\npublic:\n    string name;\n \n    explicit Tree(string name) {\n        cout &lt;&lt; name &lt;&lt; &quot; created&quot; &lt;&lt; endl;\n        this-&gt;name = std::move(name);\n    }\n};\n \nclass TreeFactory {\n    static std::unordered_map&lt;string, Tree *&gt; m;\npublic:\n    static Tree *getTree(const string &amp;name) {\n        if (m.find(name) != m.end()) return m[name];\n        Tree *tree = new Tree(name);\n        m[name] = tree;\n        return tree;\n    }\n};\n \nstd::unordered_map&lt;string, Tree *&gt; TreeFactory::m;\n \nint main() {\n    TreeFactory::getTree(&quot;A&quot;);\n    TreeFactory::getTree(&quot;B&quot;);\n    TreeFactory::getTree(&quot;A&quot;);\n}\n6. 代理模式(Proxy) §\n#include &lt;iostream&gt;\n \nusing std::cout;\nusing std::endl;\n \nclass Subject {\npublic:\n    virtual void request() {\n        cout &lt;&lt; &quot;Base&quot; &lt;&lt; endl;\n    }\n};\n \nclass Proxy : public Subject {\n    void beforeRequest() {\n        cout &lt;&lt; &quot;before&quot; &lt;&lt; endl;\n    }\n \n    void afterRequest() {\n        cout &lt;&lt; &quot;after&quot; &lt;&lt; endl;\n    }\n \n    Subject *subject;\n \npublic:\n    void request() override {\n        beforeRequest();\n        subject-&gt;request();\n        afterRequest();\n    }\n \n    Proxy() {\n        subject = new Subject();\n    }\n};\n \nint main() {\n    (new Proxy())-&gt;request();\n}\n行为模式(Behavioral Pattern) §\n1. 命令模式(Command) §\n将命令封装成对象\n\n#include&lt;iostream&gt;\n \nusing std::cout;\nusing std::endl;\n \nclass Receiver {\npublic:\n    void action() {\n        cout &lt;&lt; &quot;Receiver Action&quot; &lt;&lt; endl;\n    }\n};\n \nclass Command {\nprotected:\n    Receiver *receiver{};\npublic:\n    virtual void setReceiver(Receiver *_receiver) {\n        receiver = _receiver;\n    }\n \n    virtual void execute() = 0;\n};\n \nclass ConcreteCommand : public Command {\npublic:\n    void execute() override {\n        cout &lt;&lt; &quot;Command Execute&quot; &lt;&lt; endl;\n        receiver-&gt;action();\n    }\n};\n \nclass Invoker {\n    Command *command;\npublic:\n    explicit Invoker(Command *_command) {\n        command = _command;\n    }\n \n    void call() {\n        cout &lt;&lt; &quot;Command Invoke&quot; &lt;&lt; endl;\n        command-&gt;execute();\n    }\n};\n \nint main() {\n    Command *cmd = new ConcreteCommand();\n    cmd-&gt;setReceiver(new Receiver());\n    (new Invoker(cmd))-&gt;call();\n}"},"Y-存档/B-计算机视觉/Open3D":{"title":"Open3D Release v0.1.0","links":[],"tags":["点云"],"content":"\n\nv0.1.0\n├── CMake\n│   └── Findlibusb-1.0.cmake\n├── CMakeLists.txt\n├── Core\n│   ├── Camera\n│   ├── CMakeLists.txt\n│   ├── Core.h\n│   ├── Geometry\n│   ├── Integration\n│   ├── Odometry\n│   ├── Registration\n│   └── Utility\n├── Experimental\n│   ├── CMakeLists.txt\n│   ├── EvaluateFeatureMatch\n│   ├── EvaluatePCDMatch\n│   ├── IntegrateRGBD\n│   ├── OdometryRGBD\n│   ├── TrimMeshBasedOnPointCloud\n│   ├── ViewDistances\n│   └── ViewPCDMatch\n├── External\n│   ├── CMakeLists.txt\n│   ├── dirent\n│   ├── Eigen\n│   ├── flann\n│   ├── glew\n│   ├── GLFW\n│   ├── jsoncpp\n│   ├── libjpeg\n│   ├── liblzf\n│   ├── libpng\n│   ├── librealsense\n│   ├── pybind11\n│   ├── README.txt\n│   ├── rply\n│   ├── tinyfiledialogs\n│   └── zlib\n├── IO\n│   ├── ClassIO\n│   ├── CMakeLists.txt\n│   ├── FileFormat\n│   └── IO.h\n├── LICENSE.txt\n├── Python\n│   ├── CMakeLists.txt\n│   ├── Core\n│   ├── IO\n│   ├── py3d.cpp\n│   ├── py3d_eigen.cpp\n│   ├── py3d.h\n│   ├── Tutorial\n│   └── Visualization\n├── Test\n│   ├── CMakeLists.txt\n│   ├── TestCameraPoseTrajectory.cpp\n│   ├── TestData\n│   ├── TestDepthCapture.cpp\n│   ├── TestFileDialog.cpp\n│   ├── TestFileSystem.cpp\n│   ├── TestFlann.cpp\n│   ├── TestImage.cpp\n│   ├── TestLineSet.cpp\n│   ├── TestOpenMP.cpp\n│   ├── TestPCDFileFormat.cpp\n│   ├── TestPointCloud.cpp\n│   ├── TestPoseGraph.cpp\n│   ├── TestProgramOptions.cpp\n│   ├── TestRealSense.cpp\n│   ├── TestRegistrationRANSAC.cpp\n│   ├── TestTriangleMesh.cpp\n│   └── TestVisualizer.cpp\n├── Tools\n│   ├── CMakeLists.txt\n│   ├── ConvertPointCloud.cpp\n│   ├── EncodeShader.cpp\n│   ├── ManuallyAlignPointCloud\n│   ├── ManuallyCropPointCloud.cpp\n│   ├── MergeMesh.cpp\n│   └── ViewGeometry.cpp\n└── Visualization\n    ├── CMakeLists.txt\n    ├── Shader\n    ├── Utility\n    ├── Visualization.h\n    └── Visualizer\n\nDoc §\n通过make可以生成此次commit的文档\n需要doxygen、sphinx依赖，可以生成html文件，可以直接在浏览器打开\nCamera §\nPinholeCameraIntrinsic：保存相机的内参\nPinholeCameraTrajectory：保存相机的位姿（外参）序列, 同时拥有成员PinholeCameraIntrinsic\nGeometry §\n\nGeometry §\n几何类型，维度（Geometry2D, Geometry3D）\nGeometry2D §\n\nImage\nSelectionPolygon\n\nGeometry3D §\n\nLineSet : point_set_表示AB两个点集, lines_表示AB两个点集的对应关系\nPointCloud: 从rgbd等生成点云\nPointCloudPicker: 存储PointCloud中选择的indices\nTriangleMesh:\n\ntriangle normal: 组成三角面的顶点叉积可得\nvertex normal: 顶点构成的所有三角面的法向量的加和\nCreateMeshSphere: i循环纬度线,j循环经度线,然后通过alpha,theta角确定坐标\nCreateMeshCone: 锥体因为底部到顶点为一条线,所以多一个变量split,表示经线的分割程度,默认为1\n\n\n\nNormal §\nComputeNormal:从一堆先验确定是平面的点里面计算法向量\n通过PCA 计算点云法向量\n\n​xxyxzx​xyyyzy​xzyzzz​​\n\nCon(x,x)\n\ncov(x,x)=E[(x−E(x))(x−E(x))]=E(x2)−2∗E(x)∗E(x)+E(x)2=E(x2)−E(x)2\n\n\nCon(x,y)\n\ncov(x,y)=E[(x−E(x))(y−E(y))]=E(x2)−2∗E(x)∗E(y)+E(x)∗E(y)=E(xy)−E(x)E(y)\n\nEstimateNormals: 通过kd树做到类似于聚类的效果，然后将搜索得到的子集点云丢给ComputeNormal\nFPFH feature §\nPoint Feature Histogram: 通过数理统计的方法获得一个用于描述中心点邻域几何信息的直方图\n两两点间的局部坐标系：\nu=n1​v=u×∣∣p2​−p1​∣∣2​p2​−p1​​w=u×v\n特征描述四元组(α,ϕ,θ,d)：\nα=v∗n2​ϕ=u∗dp2​−p1​​θ=arctan(w∗n2,u∗n2)d=∣∣p2​−p1∣∣2​\n四元组计算代码实现如下：\nEigen::Vector4d ComputePairFeatures(const Eigen::Vector3d &amp;p1,\n\t\tconst Eigen::Vector3d &amp;n1, const Eigen::Vector3d &amp;p2,\n\t\tconst Eigen::Vector3d &amp;n2)\n{\n    // PFH四元组计算\n    // &lt;\\theta, \\alpha, \\phi, d&gt;\n\tEigen::Vector4d result;\n\tEigen::Vector3d dp2p1 = p2 - p1;\n    // d\n\tresult(3) = dp2p1.norm();\n\tif (result(3) == 0.0) {\n\t\treturn Eigen::Vector4d::Zero();\n\t}\n\tauto n1_copy = n1;\n\tauto n2_copy = n2;\n    // \\phi\n\tdouble angle1 = n1_copy.dot(dp2p1) / result(3);\n\tdouble angle2 = n2_copy.dot(dp2p1) / result(3);\n\tif (acos(fabs(angle1)) &gt; acos(fabs(angle2))) {\n\t\tn1_copy = n2;\n\t\tn2_copy = n1;\n\t\tdp2p1 *= -1.0;\n\t\tresult(2) = -angle2;\n\t} else {\n\t\tresult(2) = angle1;\n\t}\n\tauto v = dp2p1.cross(n1_copy);\n\tdouble v_norm = v.norm();\n\tif (v_norm == 0.0) {\n\t\treturn Eigen::Vector4d::Zero();\n\t}\n\tv /= v_norm;\n\tauto w = n1_copy.cross(v);\n    // \\alph\n\tresult(1) = v.dot(n2_copy);\n    // \\theta\n\tresult(0) = atan2(w.dot(n2_copy), n1_copy.dot(n2_copy));\n\treturn result;\n}\nHistogram 就是对四元组的特征值进行等分后对每个特征值说在区间频率的统计。\nSimplified Point Feature Histogram(SPFH): 将四元组(α,ϕ,θ,d)简化为(α,ϕ,θ)\nFast Point Feature Histogram: 基于SPFH将复杂度O(nk2)降低到O(nk)。n,k分别表示点云具有n个点以及中心邻域有 k 个点。\n\n\n对每个查询 p , 只计算其与相邻邻居点间的关联。\n\n\n使用 k 个邻居点的邻居的 SPFH 值对最终的点 p 的 FPFH 值进行加权。\n\n\nFPFH(p)=SPF(p)+k1​i=1∑k​ωk​1​∗SPF(pk​)\nωk​ 表示查询点 p 与邻居点 pk​ 间在某个度量空间下的距离。\n按照原论文中也就是上一条公式，实现应该如下所示\nfast_histArray = np.zeros_like(histArray)\nfor i in range(N):\n\tk = len(indNeigh[i])\n\tfor j in range(k):\n\t\tspfh_sum = histArray[indNeigh[i][j]]*(1/distList[i][j])\n\t\n\tfast_histArray[i, :] = histArray[i, :] + (1/k)*spfh_sum\n但是 Open3D 的实现的加权方式应该是有所不同的：\nfor (int i = 0; i &lt; (int)input.points_.size(); i++) {\n\tconst auto &amp;point = input.points_[i];\n\tstd::vector&lt;int&gt; indices;\n\tstd::vector&lt;double&gt; distance2;\n\tif (kdtree.Search(point, search_param, indices, distance2) &gt; 1) {\n\t\tdouble sum[3] = {0.0, 0.0, 0.0};\n\t\tfor (size_t k = 1; k &lt; indices.size(); k++) {\n\t\t\t// skip the point itself\n\t\t\t// \\omega_k\n\t\t\tdouble dist = distance2[k];\n\t\t\tif (dist == 0.0)\n\t\t\t\tcontinue;\n\t\t\tfor (int j = 0; j &lt; 33; j++) {\n\t\t\t\t//SPF(p_k)\n\t\t\t\tdouble val = spfh-&gt;data_(j, indices[k]) / dist;\n\t\t\t\tsum[j / 11] += val;\n\t\t\t\t// \\sum_{i=1}^{k} \\frac{1}{\\omega_k}*SPF(p_k)\n\t\t\t\tfeature-&gt;data_(j, i) += val;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j &lt; 3; j++)\n\t\t\tif (sum[j] != 0.0) sum[j] = 100.0 / sum[j];\n\t\tfor (int j = 0; j &lt; 33; j++) {\n\t\t\tfeature-&gt;data_(j, i) *= sum[j / 11];\n\t\t\t// The commented line is the fpfh function in the paper.\n\t\t\t// But according to PCL implementation, it is skipped.\n\t\t\t// Our initial test shows that the full fpfh function in the\n\t\t\t// paper seems to be better than PCL implementation. Further\n\t\t\t// test required.\n \n\t\t\t// SPF(p): spfh-&gt;data_(j, i)\n\t\t\tfeature-&gt;data_(j, i) += spfh-&gt;data_(j, i);\n\t\t}\n\t}\n}\nRegistration §\nRegistrationICP §\n输入为\n\n\nmax_correspondence_distance：kd树的搜索半径，这个变量的存在意义是在无先验匹配点对的场景下需要代码自己计算匹配点对。于是 Open3D 使用的是假设匹配点对的空间相隔较近。所以在无先验匹配的情况下，一个良好的初始值非常重要。\n\n\ninit：两个点云间的初始位姿变换，默认为单位矩阵。\n\n\nICPConvergenceCriteria：用来对 ICP 迭代停止的时间点进行判断。\n\n\nrelative_fitness\n\n\nrelative_rmse_\n\n\nmax_iteration_\n\n\n\n\nif (std::abs(backup.fitness_ - result.fitness_) &lt;\n\t\tcriteria.relative_fitness_ &amp;&amp; std::abs(backup.inlier_rmse_ -\n\t\tresult.inlier_rmse_) &lt; criteria.relative_rmse_) {\n\tbreak;\n}\nGetRegistrationResultAndCorrespondences：最主要的 ICP 调用方法。内部使用 OpenMP 的多线程方法，对每个点的最邻近点的距离进行计算，然后将他们的均方根作为 rmse。返回值为：\n\n\n符合要求的匹配点对。\n\n\ninlier_rmse_：匹配点对的均方根。\n\n\nfitness_：匹配点对占点云点总数的比例。\n\n\nRegistrationRANSACBasedOnCorrespondence §\n\n\ncorres: std::vector&lt;Eigen::Vector2i&gt;，代表 index1 和 index2 的数组。\n\n\nransac_n：做 ransac 算法使用的随机选取的数目，默认为 6.4。\n\n\nfor (int j = 0; j &lt; ransac_n; j++) {\n\transac_corres[j] = corres[std::rand() % (int)corres.size()];\n}\nTransformationEstimationPointToPoint::ComputeTransformation：\n根据对应点计算 Transformation 矩阵。\n底层调用的是 Eigen::umeyama 对初始点对进行计算。参考论文为 “Least-squares estimation of transformation parameters between two point patterns”, Shinji Umeyama, PAMI 1991, DOI: 10.1109/34.88573\n后续就是通常的 RANSAC 的最小误差迭代过程。\nCorrespondenceChecker §\nCorrespondenceChecker 作为基类，具体逻辑由子类实现。所有逻辑输入均有变量 Correspondence\n\n\nCorrespondenceCheckerBasedOnEdgeLength：使用 similarity_threshold_ 判断多边形是否具有相同的边长。如果两组点满足对应关系，那么任选一组对应点，与其剩下的所有点间的距离应该都相似。复杂度 O(n2)\n\n\nCorrespondenceCheckerBasedOnDistance：如果两组点满足对应关系，那个给定一个 transformation 变换，那个两组点应该近似重合。（无法保证点间的对应关系）复杂度 O(n)\n\n\nCorrespondenceCheckerBasedOnNormal：如果两组点满足对应关系，那个给定一个 transformation 变换，那个两组点应该满足对应点法向量方向近似一致。复杂度 O(n)\n\n\nRegistrationRANSACBasedOnFeatureMatching §\n首先外部会进行 FPFH 特征计算，并且将一组特征传入这个对齐算法。\n\n\n首先在 FPFH 的特征向量上建立 kdtree。\n\n\n然后是一个 ransac 循环，随机选择 n 个特征点。\n\n\n每个循环中根据用户设定的最近邻数量选择一个目标，复数个就随机选择一个。\n\n\n使用上一节的 CorrespondenceChecker 方法对两组匹配的特征进行检查。\n\n\n最后再使用 RegistrationRANSACBasedOnCorrespondence 进行 transformation 计算。\n\n"},"Y-存档/B-计算机视觉/camera":{"title":"Camera","links":[],"tags":[],"content":"\n\n相机将三维世界中的坐标点（单位为米）映射到二维图像平面（单位为像素）的过程 能够用一个几何模型进行描述。这个模型有很多种，其中最简单的称为针孔模型。\n单目相机 §\n针孔模型 §\n\nfZ​=X′X​=Y′Y​\nX′=fZX​Y′=fZY​\n\n\nf: 焦距\nX,Y: 三维空间相对于光心O的坐标(相机坐标系)\nX′,Y′: 投影到相对于O′的坐标\n\n像素坐标系 §\n原点 o′ 位于图像的左上角，u 轴向右与 x 轴平行，v轴向下与 y 轴平行。像素坐标系与成像平面之间，相差了一个缩放和一个原点的平移。\n设像素坐标在 u 轴上缩放了 α 倍，在 v 上缩放了 β 倍。同时，原点平移了 [cx​,cy​]T\n{u=αX′+cx​v=βy′+cy​​\n{u=fx​ZX​+cx​v=fy​ZY​+cy​​\nZ​uv1​​=​fx​00​0fy​0​cx​cy​1​​​XYZ​​=KP\n\nK: 相机内参数矩阵\nP: 相机坐标系下的点的坐标\n\n畸变 §\n\n\n径向畸变(穿过图像中心和光轴有交点的直线还能保持形状不变)\n\n\n\n\n\n\n切向畸变\n\n\n\n总结 §\n\nCamera库 §\nproject_point_radial §\n\n世界坐标系转换到相机坐标系\n\nN = P.shape[0]\nX = R.dot(P.T - T)  # rotate and translate\nPc​=RPw​+t\n\n归一化\n\nXX = X[:2, :] / X[2, :]  # 2x16\nPc​=[ZX​,ZY​,1]T\n\n调整过畸变的相机坐标转像素坐标(物理成像面)\n\nProj = (f * XXX) + c  # 2x16\nProj = Proj.T\n\n相机坐标的深度\n\nD = X[2, ]\nload_camera_params §\n\nR: 相机旋转矩阵\nT: 相机平移矩阵\nf: 相机焦距长度\nc: 相机中心\nk: 相机径向变形系数\np: 相机切向变形系数\n\n双目相机 §\n基础模型 §\n首先这个模型是基于针孔模型的\n\n\nuL​,uR​: 像素坐标\nOL​,OR​: 光心\nb: 基线\nz: 需要求的深度\n\nzz−f​=bb−uL​+uR​​\nz=dfb​,d=uL​−uR\nd为左右图的横坐标之差，称为视差"},"Y-存档/B-计算机视觉/点云":{"title":"点云","links":["C-项目/Open3D"],"tags":["点云"],"content":"\n\n点云规范化 §\n需求: 使用传统方法规范化一个长方体形状的不完全点云\n\n1. 分面 §\n\n通过Open3D的平面提取算法依次提取平面, 同时还可以得到拟合平面的方程, 作为后续优化的初始值.\n2. 平面规范化 §\n对四个面创建误差方程, 注意要加上误差权重\n\n点到面的距离最小\n\nif (isPerpendicular) {\n  // 垂直\n  return (A1 * A2 + B1 * B2 + C1 * C2) * T(weight);\n} else {\n  // 平行\n  return (normal1 * normal2 - abs(A1 * A2 + B1 * B2 + C1 * C2)) * T(weight);\n}\n\n面与面间的平行垂直误差最小\n\n// a\nresidual[0] = spatialRelation(plane_a, plane_b, false);\nresidual[1] = spatialRelation(plane_a, plane_c);\nresidual[2] = spatialRelation(plane_a, plane_d);\n \n// b\nresidual[3] = spatialRelation(plane_b, plane_c);\nresidual[4] = spatialRelation(plane_b, plane_d);\n \n// c\nresidual[5] = spatialRelation(plane_c, plane_d);\n"},"测试":{"title":"测试","links":["Y-存档/A-工程项目/前端/js-request","A-论文/3DLineDetection"],"tags":[],"content":"一级标题 §\n行内公式a=0测试\n1+1=2\n摘要摘要摘要摘要摘要摘要摘要摘要摘要摘要\nadsfadsf\n\n摘要摘要摘要摘要摘要摘要摘要摘要摘要摘要\n\n正文正文正文正文正文正文正文正文正文\n正文正文正文正文正文正文正文正文正文正文\n行内公式a=0测试\n1+1=2\n二级标题 §\n2. 测试方法\ngit 测试\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        map&lt;int, int&gt; m;\n        vector&lt;int&gt; v;\n        for(int i = 0; i &lt; nums.size(); ++i) {\n            m[nums[i]] = i;\n        }\n        for(int i = 0; i &lt; nums.size(); ++i) {\n            cout &lt;&lt; target - nums[i] &lt;&lt; &#039; &#039; &lt;&lt; m[nums[i]] &lt;&lt;endl;\n            if(m.find(target - nums[i]) != m.end() &amp;&amp; m[target - nums[i]] != i) {\n                v.push_back(i);\n                v.push_back(m[target - nums[i]]);\n                break;\n            }\n        }\n        return v;\n    }\n};\nTransclude of 3DLineDetection#plane-based-3d-line-detection"}}